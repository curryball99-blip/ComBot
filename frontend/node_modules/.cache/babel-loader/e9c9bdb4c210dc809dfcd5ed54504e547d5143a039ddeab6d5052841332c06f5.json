{"ast":null,"code":"// Updated to connect to new LangGraph backend\n\n// Updated to connect to new LangGraph backend - Server deployment configuration\n\n// Updated to connect to new LangGraph backend - Server deployment configuration\n// Determine API base URL dynamically when REACT_APP_API_URL not provided.\n// Previous logic incorrectly mapped the public IP to \"localhost\", which broke external access.\n// Rule now:\n//   1. If explicit REACT_APP_API_URL set -> use it.\n//   2. If running on localhost dev -> http://localhost:8000\n//   3. Otherwise reuse the current host (public IP or domain) with backend port 8000.\n//   4. Support same protocol upgrade if site served via https.\nconst getApiBaseUrl = () => {\n  try {\n    const {\n      protocol,\n      hostname\n    } = window.location;\n    const isLocal = ['localhost', '127.0.0.1'].includes(hostname);\n    if (isLocal || process.env.NODE_ENV === 'development') {\n      return 'http://localhost:8000';\n    }\n    // Use same protocol if https (behind reverse proxy / load balancer)\n    const backendProtocol = protocol === 'https:' ? 'https' : 'http';\n    return `${backendProtocol}://${hostname}:8000`;\n  } catch (e) {\n    // Fallback hard-coded default\n    return 'http://localhost:8000';\n  }\n};\nconst API_BASE_URL = process.env.REACT_APP_API_URL && process.env.REACT_APP_API_URL.trim() || getApiBaseUrl();\n\n// Debug logging\nif (typeof window !== 'undefined') {\n  console.log('ðŸ”§ API Configuration:', {\n    pageLocation: window.location.href,\n    hostname: window.location.hostname,\n    apiBaseUrl: API_BASE_URL,\n    env: process.env.NODE_ENV,\n    explicitEnvVar: !!process.env.REACT_APP_API_URL\n  });\n}\nexport const chatAPI = {\n  // Main sendMessage method that the chat store expects\n  sendMessage: async (message, sessionId = null, streaming = false, useInternetSearch = false, aiParams = {}) => {\n    console.log('ðŸš€ sendMessage called with:', {\n      message,\n      sessionId,\n      streaming,\n      useInternetSearch,\n      apiUrl: API_BASE_URL\n    });\n    try {\n      const requestBody = {\n        message,\n        session_id: sessionId,\n        stream: streaming,\n        internet_search: useInternetSearch,\n        ...aiParams\n      };\n      console.log('ðŸ“¡ Making request to:', `${API_BASE_URL}/api/chat`, 'with body:', requestBody);\n      const response = await fetch(`${API_BASE_URL}/api/chat`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(requestBody)\n      });\n      console.log('ðŸ“¥ Response status:', response.status, response.statusText);\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const result = await response.json();\n      console.log('âœ… API response:', result);\n      return result;\n    } catch (error) {\n      console.error('âŒ Send message API error:', error);\n      throw error;\n    }\n  },\n  // Compatibility shim: some UI code expects chatAPI.processStream.\n  // For now we don't have a true streaming backend. The store currently calls:\n  //   processStream(initialResponse, onChunk, onComplete, onError)\n  // where 'initialResponse' is the full JSON returned by sendMessage.\n  // We'll emulate streaming by splitting the full response text into word chunks\n  // and invoking callbacks. No extra network call (previous shim caused a 2nd POST with\n  // wrong argument ordering -> 422).\n  processStream: (initial, onChunk, onComplete, onError) => {\n    try {\n      // Detect signature misuse. If first param is a string, treat as message and do a fallback send.\n      if (typeof initial === 'string') {\n        console.warn('[processStream] Received string instead of initial response object; performing single non-streaming request.');\n        return async function* () {\n          const result = await chatAPI.sendMessage(initial, null, false);\n          // Simulate chunking\n          const words = (result.response || '').split(/\\s+/);\n          for (const w of words) {\n            if (onChunk) onChunk(w + ' ');\n            yield w; // allow for-await consumer\n          }\n          if (onComplete) onComplete(result);\n        }();\n      }\n      const fullText = initial && typeof initial === 'object' ? initial.response || '' : '';\n      const words = fullText.split(/\\s+/).filter(Boolean);\n\n      // Create async generator that yields each \"chunk\" (word) to satisfy for-await loop in store\n      const generator = async function* () {\n        for (const w of words) {\n          if (onChunk) onChunk(w + ' ');\n          yield w;\n        }\n        if (onComplete) onComplete(initial);\n      }();\n      return generator;\n    } catch (err) {\n      console.error('[processStream] Emulation error', err);\n      if (onError) onError(err.message || String(err));\n      // Return an empty async generator to keep caller logic safe\n      return async function* () {}();\n    }\n  },\n  chat: async (message, conversationId = null) => {\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/chat`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          message,\n          session_id: conversationId\n        })\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      return await response.json();\n    } catch (error) {\n      console.error('Chat API error:', error);\n      throw error;\n    }\n  },\n  workflow: async (message, conversationId = null) => {\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/workflow`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          message,\n          conversation_id: conversationId\n        })\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      return await response.json();\n    } catch (error) {\n      console.error('Workflow API error:', error);\n      throw error;\n    }\n  },\n  search: async (query, limit = 10) => {\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/search?query=${encodeURIComponent(query)}&limit=${limit}`, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        }\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      return await response.json();\n    } catch (error) {\n      console.error('Search API error:', error);\n      throw error;\n    }\n  },\n  clearConversation: async () => {\n    try {\n      const response = await fetch(`${API_BASE_URL}/clear-conversation`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        }\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      return await response.json();\n    } catch (error) {\n      console.error('Clear conversation error:', error);\n      throw error;\n    }\n  },\n  getConversation: async conversationId => {\n    try {\n      const response = await fetch(`${API_BASE_URL}/conversation/${conversationId}`, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        }\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      return await response.json();\n    } catch (error) {\n      console.error('Get conversation error:', error);\n      throw error;\n    }\n  }\n};\nexport const systemAPI = {\n  health: async () => {\n    try {\n      const response = await fetch(`${API_BASE_URL}/health`, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        }\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      return await response.json();\n    } catch (error) {\n      console.error('Health check error:', error);\n      throw error;\n    }\n  },\n  getSystemInfo: async () => {\n    try {\n      const response = await fetch(`${API_BASE_URL}/system/info`, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        }\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      return await response.json();\n    } catch (error) {\n      console.error('System info error:', error);\n      throw error;\n    }\n  }\n};\n\n// JIRA Dashboard API endpoints\nexport const jiraAPI = {\n  // Dashboard data\n  getDashboard: async (dateRange = '30d') => {\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/jira/dashboard?dateRange=${dateRange}`, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        }\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      return await response.json();\n    } catch (error) {\n      console.error('JIRA Dashboard API error:', error);\n      throw error;\n    }\n  },\n  // Team analytics\n  getTeamAnalytics: async (dateRange = '30d') => {\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/jira/team-analytics?dateRange=${dateRange}`, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        }\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      return await response.json();\n    } catch (error) {\n      console.error('JIRA Team Analytics API error:', error);\n      throw error;\n    }\n  },\n  // Search tickets\n  searchTickets: async (query, filters = {}) => {\n    try {\n      const params = new URLSearchParams({\n        query,\n        ...filters\n      });\n      const response = await fetch(`${API_BASE_URL}/api/jira/search?${params}`, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        }\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      return await response.json();\n    } catch (error) {\n      console.error('JIRA Search API error:', error);\n      throw error;\n    }\n  },\n  // Get member details\n  getMemberDetails: async memberId => {\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/jira/member/${memberId}`, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        }\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      return await response.json();\n    } catch (error) {\n      console.error('JIRA Member Details API error:', error);\n      throw error;\n    }\n  },\n  // Filter options\n  getFilterOptions: async () => {\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/jira/filter-options`, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        }\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      return await response.json();\n    } catch (error) {\n      console.error('JIRA Filter Options API error:', error);\n      throw error;\n    }\n  }\n};\n\n// Document processing API\nexport const documentAPI = {\n  // Upload and process document\n  uploadDocument: async (file, metadata = {}) => {\n    try {\n      const formData = new FormData();\n      formData.append('file', file);\n      formData.append('metadata', JSON.stringify(metadata));\n      const response = await fetch(`${API_BASE_URL}/api/documents/upload`, {\n        method: 'POST',\n        body: formData\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      return await response.json();\n    } catch (error) {\n      console.error('Document upload error:', error);\n      throw error;\n    }\n  },\n  // Get processing status\n  getProcessingStatus: async taskId => {\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/documents/status/${taskId}`, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        }\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      return await response.json();\n    } catch (error) {\n      console.error('Document status error:', error);\n      throw error;\n    }\n  }\n};\nexport default {\n  chatAPI,\n  systemAPI,\n  jiraAPI,\n  documentAPI\n};","map":{"version":3,"names":["getApiBaseUrl","protocol","hostname","window","location","isLocal","includes","process","env","NODE_ENV","backendProtocol","e","API_BASE_URL","REACT_APP_API_URL","trim","console","log","pageLocation","href","apiBaseUrl","explicitEnvVar","chatAPI","sendMessage","message","sessionId","streaming","useInternetSearch","aiParams","apiUrl","requestBody","session_id","stream","internet_search","response","fetch","method","headers","body","JSON","stringify","status","statusText","ok","Error","result","json","error","processStream","initial","onChunk","onComplete","onError","warn","words","split","w","fullText","filter","Boolean","generator","err","String","chat","conversationId","workflow","conversation_id","search","query","limit","encodeURIComponent","clearConversation","getConversation","systemAPI","health","getSystemInfo","jiraAPI","getDashboard","dateRange","getTeamAnalytics","searchTickets","filters","params","URLSearchParams","getMemberDetails","memberId","getFilterOptions","documentAPI","uploadDocument","file","metadata","formData","FormData","append","getProcessingStatus","taskId"],"sources":["/home/ubuntu/Ravi/ComBot/frontend/src/services/api.js"],"sourcesContent":["\n// Updated to connect to new LangGraph backend\n\n// Updated to connect to new LangGraph backend - Server deployment configuration\n\n// Updated to connect to new LangGraph backend - Server deployment configuration\n// Determine API base URL dynamically when REACT_APP_API_URL not provided.\n// Previous logic incorrectly mapped the public IP to \"localhost\", which broke external access.\n// Rule now:\n//   1. If explicit REACT_APP_API_URL set -> use it.\n//   2. If running on localhost dev -> http://localhost:8000\n//   3. Otherwise reuse the current host (public IP or domain) with backend port 8000.\n//   4. Support same protocol upgrade if site served via https.\nconst getApiBaseUrl = () => {\n  try {\n    const { protocol, hostname } = window.location;\n    const isLocal = ['localhost', '127.0.0.1'].includes(hostname);\n    if (isLocal || process.env.NODE_ENV === 'development') {\n      return 'http://localhost:8000';\n    }\n    // Use same protocol if https (behind reverse proxy / load balancer)\n    const backendProtocol = protocol === 'https:' ? 'https' : 'http';\n    return `${backendProtocol}://${hostname}:8000`;\n  } catch (e) {\n    // Fallback hard-coded default\n    return 'http://localhost:8000';\n  }\n};\n\nconst API_BASE_URL = (process.env.REACT_APP_API_URL && process.env.REACT_APP_API_URL.trim()) || getApiBaseUrl();\n\n// Debug logging\nif (typeof window !== 'undefined') {\n  console.log('ðŸ”§ API Configuration:', {\n    pageLocation: window.location.href,\n    hostname: window.location.hostname,\n    apiBaseUrl: API_BASE_URL,\n    env: process.env.NODE_ENV,\n    explicitEnvVar: !!process.env.REACT_APP_API_URL\n  });\n}\n\nexport const chatAPI = {\n  // Main sendMessage method that the chat store expects\n  sendMessage: async (message, sessionId = null, streaming = false, useInternetSearch = false, aiParams = {}) => {\n    console.log('ðŸš€ sendMessage called with:', { message, sessionId, streaming, useInternetSearch, apiUrl: API_BASE_URL });\n    try {\n      const requestBody = {\n        message,\n        session_id: sessionId,\n        stream: streaming,\n        internet_search: useInternetSearch,\n        ...aiParams\n      };\n\n      console.log('ðŸ“¡ Making request to:', `${API_BASE_URL}/api/chat`, 'with body:', requestBody);\n\n      const response = await fetch(`${API_BASE_URL}/api/chat`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(requestBody)\n      });\n\n      console.log('ðŸ“¥ Response status:', response.status, response.statusText);\n\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      const result = await response.json();\n      console.log('âœ… API response:', result);\n      return result;\n    } catch (error) {\n      console.error('âŒ Send message API error:', error);\n      throw error;\n    }\n  },\n\n  // Compatibility shim: some UI code expects chatAPI.processStream.\n  // For now we don't have a true streaming backend. The store currently calls:\n  //   processStream(initialResponse, onChunk, onComplete, onError)\n  // where 'initialResponse' is the full JSON returned by sendMessage.\n  // We'll emulate streaming by splitting the full response text into word chunks\n  // and invoking callbacks. No extra network call (previous shim caused a 2nd POST with\n  // wrong argument ordering -> 422).\n  processStream: (initial, onChunk, onComplete, onError) => {\n    try {\n      // Detect signature misuse. If first param is a string, treat as message and do a fallback send.\n      if (typeof initial === 'string') {\n        console.warn('[processStream] Received string instead of initial response object; performing single non-streaming request.');\n        return (async function * () {\n          const result = await chatAPI.sendMessage(initial, null, false);\n          // Simulate chunking\n          const words = (result.response || '').split(/\\s+/);\n            for (const w of words) {\n              if (onChunk) onChunk(w + ' ');\n              yield w; // allow for-await consumer\n            }\n          if (onComplete) onComplete(result);\n        })();\n      }\n\n      const fullText = initial && typeof initial === 'object' ? (initial.response || '') : '';\n      const words = fullText.split(/\\s+/).filter(Boolean);\n\n      // Create async generator that yields each \"chunk\" (word) to satisfy for-await loop in store\n      const generator = (async function * () {\n        for (const w of words) {\n          if (onChunk) onChunk(w + ' ');\n          yield w;\n        }\n        if (onComplete) onComplete(initial);\n      })();\n\n      return generator;\n    } catch (err) {\n      console.error('[processStream] Emulation error', err);\n      if (onError) onError(err.message || String(err));\n      // Return an empty async generator to keep caller logic safe\n      return (async function * () {})();\n    }\n  },\n\n  chat: async (message, conversationId = null) => {\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/chat`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({ message, session_id: conversationId })\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      return await response.json();\n    } catch (error) {\n      console.error('Chat API error:', error);\n      throw error;\n    }\n  },\n\n  workflow: async (message, conversationId = null) => {\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/workflow`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({ message, conversation_id: conversationId })\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      return await response.json();\n    } catch (error) {\n      console.error('Workflow API error:', error);\n      throw error;\n    }\n  },\n\n  search: async (query, limit = 10) => {\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/search?query=${encodeURIComponent(query)}&limit=${limit}`, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json',\n        }\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      return await response.json();\n    } catch (error) {\n      console.error('Search API error:', error);\n      throw error;\n    }\n  },\n\n  clearConversation: async () => {\n    try {\n      const response = await fetch(`${API_BASE_URL}/clear-conversation`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        }\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      return await response.json();\n    } catch (error) {\n      console.error('Clear conversation error:', error);\n      throw error;\n    }\n  },\n\n  getConversation: async (conversationId) => {\n    try {\n      const response = await fetch(`${API_BASE_URL}/conversation/${conversationId}`, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json',\n        }\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      return await response.json();\n    } catch (error) {\n      console.error('Get conversation error:', error);\n      throw error;\n    }\n  }\n};\n\nexport const systemAPI = {\n  health: async () => {\n    try {\n      const response = await fetch(`${API_BASE_URL}/health`, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json',\n        }\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      return await response.json();\n    } catch (error) {\n      console.error('Health check error:', error);\n      throw error;\n    }\n  },\n\n  getSystemInfo: async () => {\n    try {\n      const response = await fetch(`${API_BASE_URL}/system/info`, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json',\n        }\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      return await response.json();\n    } catch (error) {\n      console.error('System info error:', error);\n      throw error;\n    }\n  }\n};\n\n// JIRA Dashboard API endpoints\nexport const jiraAPI = {\n  // Dashboard data\n  getDashboard: async (dateRange = '30d') => {\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/jira/dashboard?dateRange=${dateRange}`, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json',\n        }\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      return await response.json();\n    } catch (error) {\n      console.error('JIRA Dashboard API error:', error);\n      throw error;\n    }\n  },\n\n  // Team analytics\n  getTeamAnalytics: async (dateRange = '30d') => {\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/jira/team-analytics?dateRange=${dateRange}`, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json',\n        }\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      return await response.json();\n    } catch (error) {\n      console.error('JIRA Team Analytics API error:', error);\n      throw error;\n    }\n  },\n\n  // Search tickets\n  searchTickets: async (query, filters = {}) => {\n    try {\n      const params = new URLSearchParams({ query, ...filters });\n      const response = await fetch(`${API_BASE_URL}/api/jira/search?${params}`, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json',\n        }\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      return await response.json();\n    } catch (error) {\n      console.error('JIRA Search API error:', error);\n      throw error;\n    }\n  },\n\n  // Get member details\n  getMemberDetails: async (memberId) => {\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/jira/member/${memberId}`, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json',\n        }\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      return await response.json();\n    } catch (error) {\n      console.error('JIRA Member Details API error:', error);\n      throw error;\n    }\n  },\n\n  // Filter options\n  getFilterOptions: async () => {\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/jira/filter-options`, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json',\n        }\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      return await response.json();\n    } catch (error) {\n      console.error('JIRA Filter Options API error:', error);\n      throw error;\n    }\n  }\n};\n\n// Document processing API\nexport const documentAPI = {\n  // Upload and process document\n  uploadDocument: async (file, metadata = {}) => {\n    try {\n      const formData = new FormData();\n      formData.append('file', file);\n      formData.append('metadata', JSON.stringify(metadata));\n\n      const response = await fetch(`${API_BASE_URL}/api/documents/upload`, {\n        method: 'POST',\n        body: formData\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      return await response.json();\n    } catch (error) {\n      console.error('Document upload error:', error);\n      throw error;\n    }\n  },\n\n  // Get processing status\n  getProcessingStatus: async (taskId) => {\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/documents/status/${taskId}`, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json',\n        }\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      return await response.json();\n    } catch (error) {\n      console.error('Document status error:', error);\n      throw error;\n    }\n  }\n};\n\nexport default {\n  chatAPI,\n  systemAPI,\n  jiraAPI,\n  documentAPI\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}