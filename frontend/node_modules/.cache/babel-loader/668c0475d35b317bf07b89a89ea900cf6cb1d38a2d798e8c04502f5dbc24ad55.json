{"ast":null,"code":"import _objectSpread from\"/home/ubuntu/Ravi/ComBot/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import{create}from'zustand';import{persist}from'zustand/middleware';import{chatAPI,sessionAPI}from'../services/api';const useChatStore=create(persist((set,get)=>({// Current conversation state\ncurrentSessionId:null,messages:[],isLoading:false,isTyping:false,error:null,// Conversation management\nconversations:[],isLoadingConversations:false,// UI state\nsidebarOpen:true,uploadModalOpen:false,// Initialize store (load conversations on app start)\ninitialize:async()=>{console.log('🚀 Initializing chat store...');try{await get().loadConversations();// If no current session and no conversations, create first one\nconst{currentSessionId,conversations}=get();if(!currentSessionId&&conversations.length===0){await get().startNewConversation('Welcome Chat');}console.log('✅ Chat store initialized');}catch(error){console.error('❌ Failed to initialize chat store:',error);}},// Actions\nsetCurrentSession:async sessionId=>{const{currentSessionId}=get();// Don't reload if it's the same session\nif(currentSessionId===sessionId){return;}console.log('🔄 Switching to session:',sessionId);// Load conversation history if sessionId exists\nif(sessionId){set({currentSessionId:sessionId,error:null});await get().loadConversationHistory(sessionId);}else{// Only clear messages for new conversation\nset({currentSessionId:sessionId,messages:[],error:null});}},// Send a message (temporarily forcing non-streaming until backend streaming stabilized)\nsendMessage:async function(messageText){let streaming=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;let useInternetSearch=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;let aiParams=arguments.length>3&&arguments[3]!==undefined?arguments[3]:{};const{currentSessionId}=get();set({isLoading:true,error:null});// Add user message immediately to UI\nconst userMessage={id:Date.now().toString(),type:'user',content:messageText,timestamp:new Date().toISOString()};set(state=>({messages:[...state.messages,userMessage],isTyping:true}));try{{// Non-streaming response (fallback)\n// Ensure UI defaults (can be overridden by caller-supplied aiParams)\nconst mergedParams=_objectSpread({legacy_mode:true},aiParams);const response=await chatAPI.sendMessage(messageText,currentSessionId,false,useInternetSearch,mergedParams);const botMessage={id:(Date.now()+1).toString(),type:'bot',content:response.response,timestamp:response.timestamp||new Date().toISOString(),sources:response.sources||[],session_id:response.session_id};set(state=>({messages:[...state.messages,botMessage],currentSessionId:response.session_id,isLoading:false,isTyping:false}));get().loadConversations();}}catch(error){console.error('Failed to send message:',error);// Add error message\nconst errorMessage={id:(Date.now()+1).toString(),type:'error',content:error.message||'Failed to get response. Please try again.',timestamp:new Date().toISOString()};set(state=>({messages:[...state.messages,errorMessage],isLoading:false,isTyping:false,error:error.message}));}},// Load conversation history (UPDATED for new API)\nloadConversationHistory:async sessionId=>{if(!sessionId)return;set({isLoading:true,error:null});try{console.log('📜 Loading history for session:',sessionId);// Use new session API\nconst history=await sessionAPI.getSessionHistory(sessionId);console.log('✅ Loaded history:',history);// Convert new history format to message format\nconst messages=[];if(history&&Array.isArray(history)){history.forEach((entry,index)=>{// New API format has user_message and assistant_response\nif(entry.user_message){messages.push({id:\"\".concat(entry.message_id||index,\"-user\"),type:'user',content:entry.user_message,timestamp:entry.timestamp});}if(entry.assistant_response){messages.push({id:\"\".concat(entry.message_id||index,\"-bot\"),type:'bot',content:entry.assistant_response,timestamp:entry.timestamp,sources:entry.sources||[]});}});}console.log('📝 Converted messages:',messages.length,'messages');set({messages,isLoading:false});}catch(error){console.error('❌ Failed to load conversation history:',error);set({isLoading:false,error:error.message});}},// Load all conversations (UPDATED for new API)\nloadConversations:async()=>{set({isLoadingConversations:true});try{const conversations=await sessionAPI.listSessions();console.log('💬 Loaded conversations:',conversations);set({conversations:conversations||[],isLoadingConversations:false});}catch(error){console.error('Failed to load conversations:',error);set({conversations:[],isLoadingConversations:false});}},// Start new conversation (UPDATED - creates proper backend session)\nstartNewConversation:async function(){let title=arguments.length>0&&arguments[0]!==undefined?arguments[0]:null;try{console.log('🆕 Creating new conversation...');// Create session via backend API\nconst newSession=await sessionAPI.createSession('default_user',title);set({currentSessionId:newSession.session_id,messages:[],error:null});// Reload conversations to show new one in sidebar\nawait get().loadConversations();console.log('✅ New conversation created:',newSession.session_id);return newSession;}catch(error){console.error('❌ Failed to create new conversation:',error);// Fallback to local session if backend fails\nconst fallbackSessionId=\"session_\".concat(Date.now(),\"_\").concat(Math.random().toString(36).substr(2,9));set({currentSessionId:fallbackSessionId,messages:[],error:null});throw error;}},// Delete conversation (UPDATED for new API)\ndeleteConversation:async sessionId=>{try{console.log('🗑️ Deleting conversation:',sessionId);// Delete via backend API\nawait sessionAPI.deleteSession(sessionId);// Remove from conversations list\nset(state=>({conversations:state.conversations.filter(conv=>conv.session_id!==sessionId)}));// If it was the current conversation, start new one\nconst{currentSessionId}=get();if(currentSessionId===sessionId){await get().startNewConversation();}console.log('✅ Conversation deleted successfully');}catch(error){console.error('❌ Failed to delete conversation:',error);set({error:error.message});}},// Rename conversation\nrenameConversation:async(sessionId,newTitle)=>{try{// Update locally first for immediate feedback\nset(state=>({conversations:state.conversations.map(conv=>conv.session_id===sessionId?_objectSpread(_objectSpread({},conv),{},{title:newTitle}):conv)}));// TODO: Add API call when backend supports it\n// await chatAPI.renameConversation(sessionId, newTitle);\n}catch(error){console.error('Failed to rename conversation:',error);// Revert on error\nget().loadConversations();set({error:error.message});}},// Clear messages (for current conversation)\nclearMessages:()=>{set({messages:[],error:null});},// Clear error\nclearError:()=>{set({error:null});},// Toggle sidebar\ntoggleSidebar:()=>{set(state=>({sidebarOpen:!state.sidebarOpen}));},// Toggle upload modal\ntoggleUploadModal:()=>{set(state=>({uploadModalOpen:!state.uploadModalOpen}));},// Set loading state\nsetLoading:isLoading=>{set({isLoading});},// Set typing state\nsetTyping:isTyping=>{set({isTyping});}}),{name:'comviva-chat-store',partialize:state=>({currentSessionId:state.currentSessionId,messages:state.messages,sidebarOpen:state.sidebarOpen,conversations:state.conversations})}));export default useChatStore;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}