{"ast":null,"code":"// Updated to connect to new LangGraph backend\n\n// Updated to connect to new LangGraph backend - Server deployment configuration\n\n// Updated to connect to new LangGraph backend - Server deployment configuration\n// Determine API base URL dynamically when REACT_APP_API_URL not provided.\n// Previous logic incorrectly mapped the public IP to \"localhost\", which broke external access.\n// Rule now:\n//   1. If explicit REACT_APP_API_URL set -> use it.\n//   2. If running on localhost dev -> http://localhost:8000\n//   3. Otherwise reuse the current host (public IP or domain) with backend port 8000.\n//   4. Support same protocol upgrade if site served via https.\nconst getApiBaseUrl = () => {\n  try {\n    const {\n      protocol,\n      hostname\n    } = window.location;\n    const isLocal = ['localhost', '127.0.0.1'].includes(hostname);\n    if (isLocal || process.env.NODE_ENV === 'development') {\n      return 'http://localhost:8000';\n    }\n    // Use same protocol if https (behind reverse proxy / load balancer)\n    const backendProtocol = protocol === 'https:' ? 'https' : 'http';\n    return `${backendProtocol}://${hostname}:8000`;\n  } catch (e) {\n    // Fallback hard-coded default\n    return 'http://localhost:8000';\n  }\n};\n\n// Resolve initial API base URL (environment override if provided)\nlet API_BASE_URL = process.env.REACT_APP_API_URL && process.env.REACT_APP_API_URL.trim() || getApiBaseUrl();\n\n// If the frontend is being accessed via localhost but the env var points to a remote IP,\n// override to localhost to avoid cross-host timeouts when doing SSH port-forwarded local dev.\ntry {\n  if (typeof window !== 'undefined') {\n    const host = window.location.hostname;\n    if ([\"localhost\", \"127.0.0.1\"].includes(host) && !API_BASE_URL.includes(host)) {\n      console.warn('[api] Detected localhost UI with remote API_BASE_URL; overriding to http://localhost:8000');\n      API_BASE_URL = 'http://localhost:8000';\n    }\n  }\n} catch (e) {\n  // ignore override errors\n}\n\n// Debug logging\nif (typeof window !== 'undefined') {\n  console.log('🔧 API Configuration:', {\n    pageLocation: window.location.href,\n    hostname: window.location.hostname,\n    apiBaseUrl: API_BASE_URL,\n    env: process.env.NODE_ENV,\n    explicitEnvVar: !!process.env.REACT_APP_API_URL\n  });\n}\nexport const chatAPI = {\n  // Main sendMessage method that the chat store expects\n  sendMessage: async (message, sessionId = null, streaming = false, useInternetSearch = false, aiParams = {}) => {\n    console.log('🚀 sendMessage called with:', {\n      message,\n      sessionId,\n      streaming,\n      useInternetSearch,\n      apiUrl: API_BASE_URL\n    });\n\n    // --- Session-aware first message detection (per session) ---\n    // Maintain module-level tracking of sessions to apply fast mode only to the first message\n    if (!chatAPI.__sessionTracker) {\n      chatAPI.__sessionTracker = {\n        lastSessionId: null\n      };\n    }\n    const tracker = chatAPI.__sessionTracker;\n    const isFirstForSession = sessionId !== tracker.lastSessionId; // Includes null -> real id transition\n\n    // Provide safe defaults that restore \"previous\" answer style & speed unless caller overrides\n    if (aiParams.legacy_mode === undefined) aiParams.legacy_mode = true;\n    if (aiParams.fast === undefined) aiParams.fast = isFirstForSession; // only first message gets fast shortcut\n\n    // Helper: timeout + retry once for transient network errors\n    const fetchWithRetry = async (url, options, {\n      timeoutMs = 15000,\n      retries = 1\n    } = {}) => {\n      for (let attempt = 0; attempt <= retries; attempt++) {\n        const controller = new AbortController();\n        const id = setTimeout(() => controller.abort(), timeoutMs);\n        try {\n          const res = await fetch(url, {\n            ...options,\n            signal: controller.signal\n          });\n          clearTimeout(id);\n          if (!res.ok) {\n            // Only retry on network-ish 5xx\n            if (res.status >= 500 && attempt < retries) {\n              console.warn(`[api] Server ${res.status} on attempt ${attempt + 1}; retrying...`);\n              await new Promise(r => setTimeout(r, 300));\n              continue;\n            }\n            const text = await res.text().catch(() => '');\n            throw new Error(`HTTP ${res.status} ${res.statusText} ${text}`.trim());\n          }\n          return res;\n        } catch (err) {\n          clearTimeout(id);\n          const retriable = err.name === 'AbortError' || /network/i.test(err.message);\n          if (attempt < retries && retriable) {\n            console.warn(`[api] Network/timeout error on attempt ${attempt + 1}; retrying...`, err.message);\n            await new Promise(r => setTimeout(r, 300));\n            continue;\n          }\n          throw err;\n        }\n      }\n      // Should never reach here\n      throw new Error('Unexpected fetchWithRetry fallthrough');\n    };\n    try {\n      const requestBody = {\n        message,\n        session_id: sessionId,\n        stream: streaming,\n        // still forwarded; backend ignores if unsupported\n        internet_search: useInternetSearch,\n        ...aiParams\n      };\n      console.log('📡 Making request to:', `${API_BASE_URL}/api/chat`, 'with body:', requestBody);\n      const response = await fetchWithRetry(`${API_BASE_URL}/api/chat`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(requestBody)\n      }, {\n        timeoutMs: 15000,\n        retries: 1\n      });\n      console.log('📥 Response status:', response.status, response.statusText);\n      const result = await response.json();\n      console.log('✅ API response:', result);\n\n      // Update tracker with returned session id (preferred) or provided one\n      tracker.lastSessionId = result.session_id || sessionId || tracker.lastSessionId;\n      return result;\n    } catch (error) {\n      if (error.name === 'AbortError') {\n        error = new Error('Request timeout after 15s (frontend abort).');\n      }\n      console.error('❌ Send message API error:', error);\n      throw error;\n    }\n  },\n  // Compatibility shim: some UI code expects chatAPI.processStream.\n  // For now we don't have a true streaming backend. The store currently calls:\n  //   processStream(initialResponse, onChunk, onComplete, onError)\n  // where 'initialResponse' is the full JSON returned by sendMessage.\n  // We'll emulate streaming by splitting the full response text into word chunks\n  // and invoking callbacks. No extra network call (previous shim caused a 2nd POST with\n  // wrong argument ordering -> 422).\n  processStream: (initial, onChunk, onComplete, onError) => {\n    try {\n      // Detect signature misuse. If first param is a string, treat as message and do a fallback send.\n      if (typeof initial === 'string') {\n        console.warn('[processStream] Received string instead of initial response object; performing single non-streaming request.');\n        return async function* () {\n          const result = await chatAPI.sendMessage(initial, null, false);\n          // Simulate chunking\n          const words = (result.response || '').split(/\\s+/);\n          for (const w of words) {\n            if (onChunk) onChunk(w + ' ');\n            yield w; // allow for-await consumer\n          }\n          if (onComplete) onComplete(result);\n        }();\n      }\n      const fullText = initial && typeof initial === 'object' ? initial.response || '' : '';\n      const words = fullText.split(/\\s+/).filter(Boolean);\n\n      // Create async generator that yields each \"chunk\" (word) to satisfy for-await loop in store\n      const generator = async function* () {\n        for (const w of words) {\n          if (onChunk) onChunk(w + ' ');\n          yield w;\n        }\n        if (onComplete) onComplete(initial);\n      }();\n      return generator;\n    } catch (err) {\n      console.error('[processStream] Emulation error', err);\n      if (onError) onError(err.message || String(err));\n      // Return an empty async generator to keep caller logic safe\n      return async function* () {}();\n    }\n  },\n  chat: async (message, conversationId = null) => {\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/chat`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          message,\n          session_id: conversationId\n        })\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      return await response.json();\n    } catch (error) {\n      console.error('Chat API error:', error);\n      throw error;\n    }\n  },\n  workflow: async (message, conversationId = null) => {\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/workflow`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          message,\n          conversation_id: conversationId\n        })\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      return await response.json();\n    } catch (error) {\n      console.error('Workflow API error:', error);\n      throw error;\n    }\n  },\n  search: async (query, limit = 10) => {\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/search?query=${encodeURIComponent(query)}&limit=${limit}`, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        }\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      return await response.json();\n    } catch (error) {\n      console.error('Search API error:', error);\n      throw error;\n    }\n  },\n  clearConversation: async () => {\n    try {\n      const response = await fetch(`${API_BASE_URL}/clear-conversation`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        }\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      return await response.json();\n    } catch (error) {\n      console.error('Clear conversation error:', error);\n      throw error;\n    }\n  },\n  getConversation: async conversationId => {\n    try {\n      const response = await fetch(`${API_BASE_URL}/conversation/${conversationId}`, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        }\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      return await response.json();\n    } catch (error) {\n      console.error('Get conversation error:', error);\n      throw error;\n    }\n  },\n  getConversationHistory: async sessionId => {\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/conversations/${sessionId}`, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        }\n      });\n      if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);\n      return await response.json();\n    } catch (error) {\n      console.error('Get conversation history error:', error);\n      throw error;\n    }\n  },\n  getAllConversations: async () => {\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/conversations`, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        }\n      });\n      if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);\n      return await response.json();\n    } catch (error) {\n      console.error('Get all conversations error:', error);\n      throw error;\n    }\n  },\n  deleteConversation: async sessionId => {\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/conversations/${sessionId}`, {\n        method: 'DELETE',\n        headers: {\n          'Content-Type': 'application/json'\n        }\n      });\n      if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);\n      return await response.json();\n    } catch (error) {\n      console.error('Delete conversation error:', error);\n      throw error;\n    }\n  }\n};\nexport const systemAPI = {\n  health: async () => {\n    try {\n      const response = await fetch(`${API_BASE_URL}/health`, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        }\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      return await response.json();\n    } catch (error) {\n      console.error('Health check error:', error);\n      throw error;\n    }\n  },\n  getSystemInfo: async () => {\n    try {\n      const response = await fetch(`${API_BASE_URL}/system/info`, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        }\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      return await response.json();\n    } catch (error) {\n      console.error('System info error:', error);\n      throw error;\n    }\n  }\n};\n\n// JIRA Dashboard API endpoints\nexport const jiraAPI = {\n  // Dashboard data\n  getDashboard: async (dateRange = '30d') => {\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/jira/dashboard?dateRange=${dateRange}`, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        }\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      return await response.json();\n    } catch (error) {\n      console.error('JIRA Dashboard API error:', error);\n      throw error;\n    }\n  },\n  // Team analytics\n  getTeamAnalytics: async (dateRange = '30d') => {\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/jira/team-analytics?dateRange=${dateRange}`, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        }\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      return await response.json();\n    } catch (error) {\n      console.error('JIRA Team Analytics API error:', error);\n      throw error;\n    }\n  },\n  // Search tickets\n  searchTickets: async (query, filters = {}) => {\n    try {\n      const params = new URLSearchParams({\n        query,\n        ...filters\n      });\n      const response = await fetch(`${API_BASE_URL}/api/jira/search?${params}`, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        }\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      return await response.json();\n    } catch (error) {\n      console.error('JIRA Search API error:', error);\n      throw error;\n    }\n  },\n  // Get member details\n  getMemberDetails: async memberId => {\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/jira/member/${memberId}`, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        }\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      return await response.json();\n    } catch (error) {\n      console.error('JIRA Member Details API error:', error);\n      throw error;\n    }\n  },\n  // Filter options\n  getFilterOptions: async () => {\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/jira/filter-options`, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        }\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      return await response.json();\n    } catch (error) {\n      console.error('JIRA Filter Options API error:', error);\n      throw error;\n    }\n  }\n};\n\n// Document processing API\nexport const documentAPI = {\n  // Upload and process document\n  uploadDocument: async (file, metadata = {}) => {\n    try {\n      const formData = new FormData();\n      formData.append('file', file);\n      formData.append('metadata', JSON.stringify(metadata));\n      const response = await fetch(`${API_BASE_URL}/api/documents/upload`, {\n        method: 'POST',\n        body: formData\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      return await response.json();\n    } catch (error) {\n      console.error('Document upload error:', error);\n      throw error;\n    }\n  },\n  // Get processing status\n  getProcessingStatus: async taskId => {\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/documents/status/${taskId}`, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        }\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      return await response.json();\n    } catch (error) {\n      console.error('Document status error:', error);\n      throw error;\n    }\n  }\n};\nexport default {\n  chatAPI,\n  systemAPI,\n  jiraAPI,\n  documentAPI\n};","map":{"version":3,"names":["getApiBaseUrl","protocol","hostname","window","location","isLocal","includes","process","env","NODE_ENV","backendProtocol","e","API_BASE_URL","REACT_APP_API_URL","trim","host","console","warn","log","pageLocation","href","apiBaseUrl","explicitEnvVar","chatAPI","sendMessage","message","sessionId","streaming","useInternetSearch","aiParams","apiUrl","__sessionTracker","lastSessionId","tracker","isFirstForSession","legacy_mode","undefined","fast","fetchWithRetry","url","options","timeoutMs","retries","attempt","controller","AbortController","id","setTimeout","abort","res","fetch","signal","clearTimeout","ok","status","Promise","r","text","catch","Error","statusText","err","retriable","name","test","requestBody","session_id","stream","internet_search","response","method","headers","body","JSON","stringify","result","json","error","processStream","initial","onChunk","onComplete","onError","words","split","w","fullText","filter","Boolean","generator","String","chat","conversationId","workflow","conversation_id","search","query","limit","encodeURIComponent","clearConversation","getConversation","getConversationHistory","getAllConversations","deleteConversation","systemAPI","health","getSystemInfo","jiraAPI","getDashboard","dateRange","getTeamAnalytics","searchTickets","filters","params","URLSearchParams","getMemberDetails","memberId","getFilterOptions","documentAPI","uploadDocument","file","metadata","formData","FormData","append","getProcessingStatus","taskId"],"sources":["/home/ubuntu/Ravi/ComBot/frontend/src/services/api.js"],"sourcesContent":["// Updated to connect to new LangGraph backend\n\n// Updated to connect to new LangGraph backend - Server deployment configuration\n\n// Updated to connect to new LangGraph backend - Server deployment configuration\n// Determine API base URL dynamically when REACT_APP_API_URL not provided.\n// Previous logic incorrectly mapped the public IP to \"localhost\", which broke external access.\n// Rule now:\n//   1. If explicit REACT_APP_API_URL set -> use it.\n//   2. If running on localhost dev -> http://localhost:8000\n//   3. Otherwise reuse the current host (public IP or domain) with backend port 8000.\n//   4. Support same protocol upgrade if site served via https.\nconst getApiBaseUrl = () => {\n  try {\n    const { protocol, hostname } = window.location;\n    const isLocal = ['localhost', '127.0.0.1'].includes(hostname);\n    if (isLocal || process.env.NODE_ENV === 'development') {\n      return 'http://localhost:8000';\n    }\n    // Use same protocol if https (behind reverse proxy / load balancer)\n    const backendProtocol = protocol === 'https:' ? 'https' : 'http';\n    return `${backendProtocol}://${hostname}:8000`;\n  } catch (e) {\n    // Fallback hard-coded default\n    return 'http://localhost:8000';\n  }\n};\n\n// Resolve initial API base URL (environment override if provided)\nlet API_BASE_URL = (process.env.REACT_APP_API_URL && process.env.REACT_APP_API_URL.trim()) || getApiBaseUrl();\n\n// If the frontend is being accessed via localhost but the env var points to a remote IP,\n// override to localhost to avoid cross-host timeouts when doing SSH port-forwarded local dev.\ntry {\n  if (typeof window !== 'undefined') {\n    const host = window.location.hostname;\n    if ([\"localhost\", \"127.0.0.1\"].includes(host) && !API_BASE_URL.includes(host)) {\n      console.warn('[api] Detected localhost UI with remote API_BASE_URL; overriding to http://localhost:8000');\n      API_BASE_URL = 'http://localhost:8000';\n    }\n  }\n} catch (e) {\n  // ignore override errors\n}\n\n// Debug logging\nif (typeof window !== 'undefined') {\n  console.log('🔧 API Configuration:', {\n    pageLocation: window.location.href,\n    hostname: window.location.hostname,\n    apiBaseUrl: API_BASE_URL,\n    env: process.env.NODE_ENV,\n    explicitEnvVar: !!process.env.REACT_APP_API_URL\n  });\n}\n\nexport const chatAPI = {\n  // Main sendMessage method that the chat store expects\n  sendMessage: async (message, sessionId = null, streaming = false, useInternetSearch = false, aiParams = {}) => {\n    console.log('🚀 sendMessage called with:', { message, sessionId, streaming, useInternetSearch, apiUrl: API_BASE_URL });\n\n    // --- Session-aware first message detection (per session) ---\n    // Maintain module-level tracking of sessions to apply fast mode only to the first message\n    if (!chatAPI.__sessionTracker) {\n      chatAPI.__sessionTracker = { lastSessionId: null };\n    }\n    const tracker = chatAPI.__sessionTracker;\n    const isFirstForSession = sessionId !== tracker.lastSessionId; // Includes null -> real id transition\n\n    // Provide safe defaults that restore \"previous\" answer style & speed unless caller overrides\n    if (aiParams.legacy_mode === undefined) aiParams.legacy_mode = true;\n    if (aiParams.fast === undefined) aiParams.fast = isFirstForSession; // only first message gets fast shortcut\n\n    // Helper: timeout + retry once for transient network errors\n    const fetchWithRetry = async (url, options, { timeoutMs = 15000, retries = 1 } = {}) => {\n      for (let attempt = 0; attempt <= retries; attempt++) {\n        const controller = new AbortController();\n        const id = setTimeout(() => controller.abort(), timeoutMs);\n        try {\n          const res = await fetch(url, { ...options, signal: controller.signal });\n          clearTimeout(id);\n          if (!res.ok) {\n            // Only retry on network-ish 5xx\n            if (res.status >= 500 && attempt < retries) {\n              console.warn(`[api] Server ${res.status} on attempt ${attempt + 1}; retrying...`);\n              await new Promise(r => setTimeout(r, 300));\n              continue;\n            }\n            const text = await res.text().catch(() => '');\n            throw new Error(`HTTP ${res.status} ${res.statusText} ${text}`.trim());\n          }\n          return res;\n        } catch (err) {\n          clearTimeout(id);\n          const retriable = err.name === 'AbortError' || /network/i.test(err.message);\n          if (attempt < retries && retriable) {\n            console.warn(`[api] Network/timeout error on attempt ${attempt + 1}; retrying...`, err.message);\n            await new Promise(r => setTimeout(r, 300));\n            continue;\n          }\n          throw err;\n        }\n      }\n      // Should never reach here\n      throw new Error('Unexpected fetchWithRetry fallthrough');\n    };\n\n    try {\n      const requestBody = {\n        message,\n        session_id: sessionId,\n        stream: streaming, // still forwarded; backend ignores if unsupported\n        internet_search: useInternetSearch,\n        ...aiParams\n      };\n\n      console.log('📡 Making request to:', `${API_BASE_URL}/api/chat`, 'with body:', requestBody);\n\n      const response = await fetchWithRetry(`${API_BASE_URL}/api/chat`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(requestBody)\n      }, { timeoutMs: 15000, retries: 1 });\n\n      console.log('📥 Response status:', response.status, response.statusText);\n\n      const result = await response.json();\n      console.log('✅ API response:', result);\n\n      // Update tracker with returned session id (preferred) or provided one\n      tracker.lastSessionId = result.session_id || sessionId || tracker.lastSessionId;\n      return result;\n    } catch (error) {\n      if (error.name === 'AbortError') {\n        error = new Error('Request timeout after 15s (frontend abort).');\n      }\n      console.error('❌ Send message API error:', error);\n      throw error;\n    }\n  },\n\n  // Compatibility shim: some UI code expects chatAPI.processStream.\n  // For now we don't have a true streaming backend. The store currently calls:\n  //   processStream(initialResponse, onChunk, onComplete, onError)\n  // where 'initialResponse' is the full JSON returned by sendMessage.\n  // We'll emulate streaming by splitting the full response text into word chunks\n  // and invoking callbacks. No extra network call (previous shim caused a 2nd POST with\n  // wrong argument ordering -> 422).\n  processStream: (initial, onChunk, onComplete, onError) => {\n    try {\n      // Detect signature misuse. If first param is a string, treat as message and do a fallback send.\n      if (typeof initial === 'string') {\n        console.warn('[processStream] Received string instead of initial response object; performing single non-streaming request.');\n        return (async function* () {\n          const result = await chatAPI.sendMessage(initial, null, false);\n          // Simulate chunking\n          const words = (result.response || '').split(/\\s+/);\n          for (const w of words) {\n            if (onChunk) onChunk(w + ' ');\n            yield w; // allow for-await consumer\n          }\n          if (onComplete) onComplete(result);\n        })();\n      }\n\n      const fullText = initial && typeof initial === 'object' ? (initial.response || '') : '';\n      const words = fullText.split(/\\s+/).filter(Boolean);\n\n      // Create async generator that yields each \"chunk\" (word) to satisfy for-await loop in store\n      const generator = (async function* () {\n        for (const w of words) {\n          if (onChunk) onChunk(w + ' ');\n          yield w;\n        }\n        if (onComplete) onComplete(initial);\n      })();\n\n      return generator;\n    } catch (err) {\n      console.error('[processStream] Emulation error', err);\n      if (onError) onError(err.message || String(err));\n      // Return an empty async generator to keep caller logic safe\n      return (async function* () { })();\n    }\n  },\n\n  chat: async (message, conversationId = null) => {\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/chat`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({ message, session_id: conversationId })\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      return await response.json();\n    } catch (error) {\n      console.error('Chat API error:', error);\n      throw error;\n    }\n  },\n\n  workflow: async (message, conversationId = null) => {\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/workflow`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({ message, conversation_id: conversationId })\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      return await response.json();\n    } catch (error) {\n      console.error('Workflow API error:', error);\n      throw error;\n    }\n  },\n\n  search: async (query, limit = 10) => {\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/search?query=${encodeURIComponent(query)}&limit=${limit}`, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json',\n        }\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      return await response.json();\n    } catch (error) {\n      console.error('Search API error:', error);\n      throw error;\n    }\n  },\n\n  clearConversation: async () => {\n    try {\n      const response = await fetch(`${API_BASE_URL}/clear-conversation`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        }\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      return await response.json();\n    } catch (error) {\n      console.error('Clear conversation error:', error);\n      throw error;\n    }\n  },\n\n  getConversation: async (conversationId) => {\n    try {\n      const response = await fetch(`${API_BASE_URL}/conversation/${conversationId}`, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json',\n        }\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      return await response.json();\n    } catch (error) {\n      console.error('Get conversation error:', error);\n      throw error;\n    }\n  },\n\n  getConversationHistory: async (sessionId) => {\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/conversations/${sessionId}`, {\n        method: 'GET',\n        headers: { 'Content-Type': 'application/json' }\n      });\n      if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);\n      return await response.json();\n    } catch (error) {\n      console.error('Get conversation history error:', error);\n      throw error;\n    }\n  },\n  getAllConversations: async () => {\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/conversations`, {\n        method: 'GET',\n        headers: { 'Content-Type': 'application/json' }\n      });\n      if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);\n      return await response.json();\n    } catch (error) {\n      console.error('Get all conversations error:', error);\n      throw error;\n    }\n  },\n  deleteConversation: async (sessionId) => {\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/conversations/${sessionId}`, {\n        method: 'DELETE',\n        headers: { 'Content-Type': 'application/json' }\n      });\n      if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);\n      return await response.json();\n    } catch (error) {\n      console.error('Delete conversation error:', error);\n      throw error;\n    }\n  },\n};\n\nexport const systemAPI = {\n  health: async () => {\n    try {\n      const response = await fetch(`${API_BASE_URL}/health`, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json',\n        }\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      return await response.json();\n    } catch (error) {\n      console.error('Health check error:', error);\n      throw error;\n    }\n  },\n\n  getSystemInfo: async () => {\n    try {\n      const response = await fetch(`${API_BASE_URL}/system/info`, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json',\n        }\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      return await response.json();\n    } catch (error) {\n      console.error('System info error:', error);\n      throw error;\n    }\n  }\n};\n\n// JIRA Dashboard API endpoints\nexport const jiraAPI = {\n  // Dashboard data\n  getDashboard: async (dateRange = '30d') => {\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/jira/dashboard?dateRange=${dateRange}`, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json',\n        }\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      return await response.json();\n    } catch (error) {\n      console.error('JIRA Dashboard API error:', error);\n      throw error;\n    }\n  },\n\n  // Team analytics\n  getTeamAnalytics: async (dateRange = '30d') => {\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/jira/team-analytics?dateRange=${dateRange}`, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json',\n        }\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      return await response.json();\n    } catch (error) {\n      console.error('JIRA Team Analytics API error:', error);\n      throw error;\n    }\n  },\n\n  // Search tickets\n  searchTickets: async (query, filters = {}) => {\n    try {\n      const params = new URLSearchParams({ query, ...filters });\n      const response = await fetch(`${API_BASE_URL}/api/jira/search?${params}`, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json',\n        }\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      return await response.json();\n    } catch (error) {\n      console.error('JIRA Search API error:', error);\n      throw error;\n    }\n  },\n\n  // Get member details\n  getMemberDetails: async (memberId) => {\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/jira/member/${memberId}`, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json',\n        }\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      return await response.json();\n    } catch (error) {\n      console.error('JIRA Member Details API error:', error);\n      throw error;\n    }\n  },\n\n  // Filter options\n  getFilterOptions: async () => {\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/jira/filter-options`, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json',\n        }\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      return await response.json();\n    } catch (error) {\n      console.error('JIRA Filter Options API error:', error);\n      throw error;\n    }\n  }\n};\n\n// Document processing API\nexport const documentAPI = {\n  // Upload and process document\n  uploadDocument: async (file, metadata = {}) => {\n    try {\n      const formData = new FormData();\n      formData.append('file', file);\n      formData.append('metadata', JSON.stringify(metadata));\n\n      const response = await fetch(`${API_BASE_URL}/api/documents/upload`, {\n        method: 'POST',\n        body: formData\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      return await response.json();\n    } catch (error) {\n      console.error('Document upload error:', error);\n      throw error;\n    }\n  },\n\n  // Get processing status\n  getProcessingStatus: async (taskId) => {\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/documents/status/${taskId}`, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json',\n        }\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      return await response.json();\n    } catch (error) {\n      console.error('Document status error:', error);\n      throw error;\n    }\n  }\n};\n\nexport default {\n  chatAPI,\n  systemAPI,\n  jiraAPI,\n  documentAPI\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}