{"ast":null,"code":"import _objectSpread from\"/home/ubuntu/Ravi/ComBot/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import{create}from'zustand';import{persist}from'zustand/middleware';import{chatAPI}from'../services/api';const useChatStore=create(persist((set,get)=>({// Current conversation state\ncurrentSessionId:null,messages:[],isLoading:false,isTyping:false,error:null,// Conversation management\nconversations:[],isLoadingConversations:false,// UI state\nsidebarOpen:true,uploadModalOpen:false,// Actions\nsetCurrentSession:async sessionId=>{const{currentSessionId}=get();// Don't reload if it's the same session\nif(currentSessionId===sessionId){return;}// Load conversation history if sessionId exists\nif(sessionId){set({currentSessionId:sessionId,error:null});await get().loadConversationHistory(sessionId);}else{// Only clear messages for new conversation\nset({currentSessionId:sessionId,messages:[],error:null});}},// Send a message (temporarily forcing non-streaming until backend streaming stabilized)\nsendMessage:async function(messageText){let streaming=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;let useInternetSearch=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;let aiParams=arguments.length>3&&arguments[3]!==undefined?arguments[3]:{};const{currentSessionId}=get();set({isLoading:true,error:null});// Add user message immediately to UI\nconst userMessage={id:Date.now().toString(),type:'user',content:messageText,timestamp:new Date().toISOString()};set(state=>({messages:[...state.messages,userMessage],isTyping:true}));try{{// Non-streaming response (fallback)\n// Ensure UI defaults (can be overridden by caller-supplied aiParams)\nconst mergedParams=_objectSpread({legacy_mode:true},aiParams);const response=await chatAPI.sendMessage(messageText,currentSessionId,false,useInternetSearch,mergedParams);const botMessage={id:(Date.now()+1).toString(),type:'bot',content:response.response,timestamp:response.timestamp||new Date().toISOString(),sources:response.sources||[],session_id:response.session_id};set(state=>({messages:[...state.messages,botMessage],currentSessionId:response.session_id,isLoading:false,isTyping:false}));get().loadConversations();}}catch(error){console.error('Failed to send message:',error);// Add error message\nconst errorMessage={id:(Date.now()+1).toString(),type:'error',content:error.message||'Failed to get response. Please try again.',timestamp:new Date().toISOString()};set(state=>({messages:[...state.messages,errorMessage],isLoading:false,isTyping:false,error:error.message}));}},// Load conversation history\nloadConversationHistory:async sessionId=>{if(!sessionId)return;set({isLoading:true,error:null});try{const history=await chatAPI.getConversationHistory(sessionId);console.log('Loaded history for session:',sessionId,history);console.log('First entry structure:',history[0]);// Convert history to message format\nconst messages=[];if(history&&Array.isArray(history)){history.forEach(entry=>{if(entry.query){messages.push({id:\"\".concat(entry.id,\"-user\"),type:'user',content:entry.query,timestamp:entry.timestamp});}if(entry.response){messages.push({id:\"\".concat(entry.id,\"-bot\"),type:'bot',content:entry.response,timestamp:entry.timestamp,sources:entry.sources||[]});}});}console.log('Converted messages:',messages);set({messages,isLoading:false});}catch(error){console.error('Failed to load conversation history:',error);set({isLoading:false,error:error.message});}},// Load all conversations\nloadConversations:async()=>{set({isLoadingConversations:true});try{const conversations=await chatAPI.getAllConversations();set({conversations:conversations||[],isLoadingConversations:false});}catch(error){console.error('Failed to load conversations:',error);set({conversations:[],isLoadingConversations:false});}},// Start new conversation\nstartNewConversation:()=>{const newSessionId=\"session_\".concat(Date.now(),\"_\").concat(Math.random().toString(36).substr(2,9));set({currentSessionId:newSessionId,messages:[],error:null});},// Delete conversation\ndeleteConversation:async sessionId=>{try{await chatAPI.deleteConversation(sessionId);// Remove from conversations list\nset(state=>({conversations:state.conversations.filter(conv=>conv.session_id!==sessionId)}));// If it was the current conversation, start new one\nconst{currentSessionId}=get();if(currentSessionId===sessionId){get().startNewConversation();}}catch(error){console.error('Failed to delete conversation:',error);set({error:error.message});}},// Rename conversation\nrenameConversation:async(sessionId,newTitle)=>{try{// Update locally first for immediate feedback\nset(state=>({conversations:state.conversations.map(conv=>conv.session_id===sessionId?_objectSpread(_objectSpread({},conv),{},{title:newTitle}):conv)}));// TODO: Add API call when backend supports it\n// await chatAPI.renameConversation(sessionId, newTitle);\n}catch(error){console.error('Failed to rename conversation:',error);// Revert on error\nget().loadConversations();set({error:error.message});}},// Clear messages (for current conversation)\nclearMessages:()=>{set({messages:[],error:null});},// Clear error\nclearError:()=>{set({error:null});},// Toggle sidebar\ntoggleSidebar:()=>{set(state=>({sidebarOpen:!state.sidebarOpen}));},// Toggle upload modal\ntoggleUploadModal:()=>{set(state=>({uploadModalOpen:!state.uploadModalOpen}));},// Set loading state\nsetLoading:isLoading=>{set({isLoading});},// Set typing state\nsetTyping:isTyping=>{set({isTyping});}}),{name:'comviva-chat-store',partialize:state=>({currentSessionId:state.currentSessionId,messages:state.messages,sidebarOpen:state.sidebarOpen,conversations:state.conversations})}));export default useChatStore;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}