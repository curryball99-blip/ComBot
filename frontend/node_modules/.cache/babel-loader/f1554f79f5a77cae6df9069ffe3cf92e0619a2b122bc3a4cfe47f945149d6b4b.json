{"ast":null,"code":"import { create } from 'zustand';\nimport { persist } from 'zustand/middleware';\nimport { chatAPI } from '../services/api';\nconst useChatStore = create(persist((set, get) => ({\n  // Current conversation state\n  currentSessionId: null,\n  messages: [],\n  isLoading: false,\n  isTyping: false,\n  error: null,\n  // Conversation management\n  conversations: [],\n  isLoadingConversations: false,\n  // UI state\n  sidebarOpen: true,\n  uploadModalOpen: false,\n  // Actions\n  setCurrentSession: async sessionId => {\n    const {\n      currentSessionId\n    } = get();\n\n    // Don't reload if it's the same session\n    if (currentSessionId === sessionId) {\n      return;\n    }\n    set({\n      currentSessionId: sessionId,\n      error: null\n    });\n\n    // Load conversation history if sessionId exists\n    if (sessionId) {\n      await get().loadConversationHistory(sessionId);\n    } else {\n      // Only clear messages for new conversation\n      set({\n        messages: []\n      });\n    }\n  },\n  // Send a message with streaming support\n  sendMessage: async (messageText, streaming = false) => {\n    const {\n      currentSessionId\n    } = get();\n    set({\n      isLoading: true,\n      error: null\n    });\n\n    // Add user message immediately to UI\n    const userMessage = {\n      id: Date.now().toString(),\n      type: 'user',\n      content: messageText,\n      timestamp: new Date().toISOString()\n    };\n    set(state => ({\n      messages: [...state.messages, userMessage],\n      isTyping: true\n    }));\n    try {\n      if (streaming) {\n        // Streaming response\n        const response = await chatAPI.sendMessage(messageText, currentSessionId, true);\n\n        // Create initial bot message\n        const botMessageId = (Date.now() + 1).toString();\n        const botMessage = {\n          id: botMessageId,\n          type: 'bot',\n          content: '',\n          timestamp: new Date().toISOString(),\n          sources: [],\n          isStreaming: true\n        };\n        set(state => ({\n          messages: [...state.messages, botMessage],\n          isLoading: false,\n          isTyping: false\n        }));\n\n        // Process streaming response\n        let fullContent = '';\n        const streamGenerator = chatAPI.processStream(response, chunk => {\n          // Split chunk into words for smoother streaming\n          const words = chunk.split(' ');\n          let wordIndex = 0;\n          const addWordsGradually = () => {\n            if (wordIndex < words.length) {\n              fullContent += (wordIndex > 0 ? ' ' : '') + words[wordIndex];\n              wordIndex++;\n\n              // Update the message\n              set(state => ({\n                messages: state.messages.map(msg => msg.id === botMessageId ? {\n                  ...msg,\n                  content: fullContent\n                } : msg)\n              }));\n\n              // Continue with next word after delay\n              if (wordIndex < words.length) {\n                setTimeout(addWordsGradually, 50); // 50ms delay between words\n              }\n            }\n          };\n          addWordsGradually();\n        }, completionData => {\n          // Final update with metadata\n          set(state => ({\n            messages: state.messages.map(msg => msg.id === botMessageId ? {\n              ...msg,\n              content: fullContent,\n              sources: completionData.sources || [],\n              timestamp: completionData.timestamp,\n              isStreaming: false\n            } : msg),\n            currentSessionId: completionData.session_id\n          }));\n\n          // Refresh conversations list\n          get().loadConversations();\n        }, error => {\n          console.error('Streaming error:', error);\n          set(state => ({\n            messages: state.messages.map(msg => msg.id === botMessageId ? {\n              ...msg,\n              type: 'error',\n              content: error,\n              isStreaming: false\n            } : msg),\n            error\n          }));\n        });\n\n        // Consume the generator\n        try {\n          // eslint-disable-next-line no-unused-vars\n          for await (const _ of streamGenerator) {\n            // Chunks are processed in the onChunk callback\n          }\n        } catch (streamError) {\n          console.error('Stream processing error:', streamError);\n        }\n      } else {\n        // Non-streaming response (fallback)\n        const response = await chatAPI.sendMessage(messageText, currentSessionId, false);\n        const botMessage = {\n          id: (Date.now() + 1).toString(),\n          type: 'bot',\n          content: response.response,\n          timestamp: response.timestamp || new Date().toISOString(),\n          sources: response.sources || [],\n          session_id: response.session_id\n        };\n        set(state => ({\n          messages: [...state.messages, botMessage],\n          currentSessionId: response.session_id,\n          isLoading: false,\n          isTyping: false\n        }));\n        get().loadConversations();\n      }\n    } catch (error) {\n      console.error('Failed to send message:', error);\n\n      // Add error message\n      const errorMessage = {\n        id: (Date.now() + 1).toString(),\n        type: 'error',\n        content: error.message || 'Failed to get response. Please try again.',\n        timestamp: new Date().toISOString()\n      };\n      set(state => ({\n        messages: [...state.messages, errorMessage],\n        isLoading: false,\n        isTyping: false,\n        error: error.message\n      }));\n    }\n  },\n  // Load conversation history\n  loadConversationHistory: async sessionId => {\n    if (!sessionId) return;\n    set({\n      isLoading: true,\n      error: null\n    });\n    try {\n      const history = await chatAPI.getConversationHistory(sessionId);\n\n      // Convert history to message format\n      const messages = [];\n      history.forEach(entry => {\n        if (entry.user_message) {\n          messages.push({\n            id: `${entry.id}-user`,\n            type: 'user',\n            content: entry.user_message,\n            timestamp: entry.timestamp\n          });\n        }\n        if (entry.bot_response) {\n          messages.push({\n            id: `${entry.id}-bot`,\n            type: 'bot',\n            content: entry.bot_response,\n            timestamp: entry.timestamp,\n            sources: entry.sources || []\n          });\n        }\n      });\n      set({\n        messages,\n        currentSessionId: sessionId,\n        isLoading: false\n      });\n    } catch (error) {\n      console.error('Failed to load conversation history:', error);\n      set({\n        isLoading: false,\n        error: error.message\n      });\n    }\n  },\n  // Load all conversations\n  loadConversations: async () => {\n    set({\n      isLoadingConversations: true\n    });\n    try {\n      const conversations = await chatAPI.getAllConversations();\n      set({\n        conversations: conversations || [],\n        isLoadingConversations: false\n      });\n    } catch (error) {\n      console.error('Failed to load conversations:', error);\n      set({\n        conversations: [],\n        isLoadingConversations: false\n      });\n    }\n  },\n  // Start new conversation\n  startNewConversation: () => {\n    set({\n      currentSessionId: null,\n      messages: [],\n      error: null\n    });\n  },\n  // Delete conversation\n  deleteConversation: async sessionId => {\n    try {\n      await chatAPI.deleteConversation(sessionId);\n\n      // Remove from conversations list\n      set(state => ({\n        conversations: state.conversations.filter(conv => conv.session_id !== sessionId)\n      }));\n\n      // If it was the current conversation, start new one\n      const {\n        currentSessionId\n      } = get();\n      if (currentSessionId === sessionId) {\n        get().startNewConversation();\n      }\n    } catch (error) {\n      console.error('Failed to delete conversation:', error);\n      set({\n        error: error.message\n      });\n    }\n  },\n  // Clear messages (for current conversation)\n  clearMessages: () => {\n    set({\n      messages: [],\n      error: null\n    });\n  },\n  // Clear error\n  clearError: () => {\n    set({\n      error: null\n    });\n  },\n  // Toggle sidebar\n  toggleSidebar: () => {\n    set(state => ({\n      sidebarOpen: !state.sidebarOpen\n    }));\n  },\n  // Toggle upload modal\n  toggleUploadModal: () => {\n    set(state => ({\n      uploadModalOpen: !state.uploadModalOpen\n    }));\n  },\n  // Set loading state\n  setLoading: isLoading => {\n    set({\n      isLoading\n    });\n  },\n  // Set typing state\n  setTyping: isTyping => {\n    set({\n      isTyping\n    });\n  }\n}), {\n  name: 'comviva-chat-store',\n  partialize: state => ({\n    currentSessionId: state.currentSessionId,\n    messages: state.messages,\n    sidebarOpen: state.sidebarOpen,\n    conversations: state.conversations\n  })\n}));\nexport default useChatStore;","map":{"version":3,"names":["create","persist","chatAPI","useChatStore","set","get","currentSessionId","messages","isLoading","isTyping","error","conversations","isLoadingConversations","sidebarOpen","uploadModalOpen","setCurrentSession","sessionId","loadConversationHistory","sendMessage","messageText","streaming","userMessage","id","Date","now","toString","type","content","timestamp","toISOString","state","response","botMessageId","botMessage","sources","isStreaming","fullContent","streamGenerator","processStream","chunk","words","split","wordIndex","addWordsGradually","length","map","msg","setTimeout","completionData","session_id","loadConversations","console","_","streamError","errorMessage","message","history","getConversationHistory","forEach","entry","user_message","push","bot_response","getAllConversations","startNewConversation","deleteConversation","filter","conv","clearMessages","clearError","toggleSidebar","toggleUploadModal","setLoading","setTyping","name","partialize"],"sources":["/home/im/Druthik/clean_rag/frontend/src/stores/chatStore.js"],"sourcesContent":["import { create } from 'zustand';\nimport { persist } from 'zustand/middleware';\nimport { chatAPI } from '../services/api';\n\nconst useChatStore = create(\n  persist(\n    (set, get) => ({\n      // Current conversation state\n      currentSessionId: null,\n      messages: [],\n      isLoading: false,\n      isTyping: false,\n      error: null,\n\n      // Conversation management\n      conversations: [],\n      isLoadingConversations: false,\n\n      // UI state\n      sidebarOpen: true,\n      uploadModalOpen: false,\n\n      // Actions\n      setCurrentSession: async (sessionId) => {\n        const { currentSessionId } = get();\n        \n        // Don't reload if it's the same session\n        if (currentSessionId === sessionId) {\n          return;\n        }\n        \n        set({ currentSessionId: sessionId, error: null });\n        \n        // Load conversation history if sessionId exists\n        if (sessionId) {\n          await get().loadConversationHistory(sessionId);\n        } else {\n          // Only clear messages for new conversation\n          set({ messages: [] });\n        }\n      },\n\n      // Send a message with streaming support\n      sendMessage: async (messageText, streaming = false) => {\n        const { currentSessionId } = get();\n        \n        set({ isLoading: true, error: null });\n\n        // Add user message immediately to UI\n        const userMessage = {\n          id: Date.now().toString(),\n          type: 'user',\n          content: messageText,\n          timestamp: new Date().toISOString(),\n        };\n\n        set((state) => ({\n          messages: [...state.messages, userMessage],\n          isTyping: true,\n        }));\n\n        try {\n          if (streaming) {\n            // Streaming response\n            const response = await chatAPI.sendMessage(messageText, currentSessionId, true);\n            \n            // Create initial bot message\n            const botMessageId = (Date.now() + 1).toString();\n            const botMessage = {\n              id: botMessageId,\n              type: 'bot',\n              content: '',\n              timestamp: new Date().toISOString(),\n              sources: [],\n              isStreaming: true,\n            };\n\n            set((state) => ({\n              messages: [...state.messages, botMessage],\n              isLoading: false,\n              isTyping: false,\n            }));\n\n            // Process streaming response\n            let fullContent = '';\n            const streamGenerator = chatAPI.processStream(\n              response,\n              (chunk) => {\n                // Split chunk into words for smoother streaming\n                const words = chunk.split(' ');\n                let wordIndex = 0;\n                \n                const addWordsGradually = () => {\n                  if (wordIndex < words.length) {\n                    fullContent += (wordIndex > 0 ? ' ' : '') + words[wordIndex];\n                    wordIndex++;\n                    \n                    // Update the message\n                    set((state) => ({\n                      messages: state.messages.map((msg) =>\n                        msg.id === botMessageId\n                          ? { ...msg, content: fullContent }\n                          : msg\n                      ),\n                    }));\n                    \n                    // Continue with next word after delay\n                    if (wordIndex < words.length) {\n                      setTimeout(addWordsGradually, 50); // 50ms delay between words\n                    }\n                  }\n                };\n                \n                addWordsGradually();\n              },\n              (completionData) => {\n                // Final update with metadata\n                set((state) => ({\n                  messages: state.messages.map((msg) =>\n                    msg.id === botMessageId\n                      ? {\n                          ...msg,\n                          content: fullContent,\n                          sources: completionData.sources || [],\n                          timestamp: completionData.timestamp,\n                          isStreaming: false,\n                        }\n                      : msg\n                  ),\n                  currentSessionId: completionData.session_id,\n                }));\n\n                // Refresh conversations list\n                get().loadConversations();\n              },\n              (error) => {\n                console.error('Streaming error:', error);\n                set((state) => ({\n                  messages: state.messages.map((msg) =>\n                    msg.id === botMessageId\n                      ? { ...msg, type: 'error', content: error, isStreaming: false }\n                      : msg\n                  ),\n                  error,\n                }));\n              }\n            );\n\n            // Consume the generator\n            try {\n              // eslint-disable-next-line no-unused-vars\n              for await (const _ of streamGenerator) {\n                // Chunks are processed in the onChunk callback\n              }\n            } catch (streamError) {\n              console.error('Stream processing error:', streamError);\n            }\n\n          } else {\n            // Non-streaming response (fallback)\n            const response = await chatAPI.sendMessage(messageText, currentSessionId, false);\n            \n            const botMessage = {\n              id: (Date.now() + 1).toString(),\n              type: 'bot',\n              content: response.response,\n              timestamp: response.timestamp || new Date().toISOString(),\n              sources: response.sources || [],\n              session_id: response.session_id,\n            };\n\n            set((state) => ({\n              messages: [...state.messages, botMessage],\n              currentSessionId: response.session_id,\n              isLoading: false,\n              isTyping: false,\n            }));\n\n            get().loadConversations();\n          }\n\n        } catch (error) {\n          console.error('Failed to send message:', error);\n          \n          // Add error message\n          const errorMessage = {\n            id: (Date.now() + 1).toString(),\n            type: 'error',\n            content: error.message || 'Failed to get response. Please try again.',\n            timestamp: new Date().toISOString(),\n          };\n\n          set((state) => ({\n            messages: [...state.messages, errorMessage],\n            isLoading: false,\n            isTyping: false,\n            error: error.message,\n          }));\n        }\n      },\n\n      // Load conversation history\n      loadConversationHistory: async (sessionId) => {\n        if (!sessionId) return;\n\n        set({ isLoading: true, error: null });\n\n        try {\n          const history = await chatAPI.getConversationHistory(sessionId);\n          \n          // Convert history to message format\n          const messages = [];\n          history.forEach((entry) => {\n            if (entry.user_message) {\n              messages.push({\n                id: `${entry.id}-user`,\n                type: 'user',\n                content: entry.user_message,\n                timestamp: entry.timestamp,\n              });\n            }\n            if (entry.bot_response) {\n              messages.push({\n                id: `${entry.id}-bot`,\n                type: 'bot',\n                content: entry.bot_response,\n                timestamp: entry.timestamp,\n                sources: entry.sources || [],\n              });\n            }\n          });\n\n          set({\n            messages,\n            currentSessionId: sessionId,\n            isLoading: false,\n          });\n\n        } catch (error) {\n          console.error('Failed to load conversation history:', error);\n          set({\n            isLoading: false,\n            error: error.message,\n          });\n        }\n      },\n\n      // Load all conversations\n      loadConversations: async () => {\n        set({ isLoadingConversations: true });\n\n        try {\n          const conversations = await chatAPI.getAllConversations();\n          set({\n            conversations: conversations || [],\n            isLoadingConversations: false,\n          });\n        } catch (error) {\n          console.error('Failed to load conversations:', error);\n          set({\n            conversations: [],\n            isLoadingConversations: false,\n          });\n        }\n      },\n\n      // Start new conversation\n      startNewConversation: () => {\n        set({\n          currentSessionId: null,\n          messages: [],\n          error: null,\n        });\n      },\n\n      // Delete conversation\n      deleteConversation: async (sessionId) => {\n        try {\n          await chatAPI.deleteConversation(sessionId);\n          \n          // Remove from conversations list\n          set((state) => ({\n            conversations: state.conversations.filter(\n              (conv) => conv.session_id !== sessionId\n            ),\n          }));\n\n          // If it was the current conversation, start new one\n          const { currentSessionId } = get();\n          if (currentSessionId === sessionId) {\n            get().startNewConversation();\n          }\n\n        } catch (error) {\n          console.error('Failed to delete conversation:', error);\n          set({ error: error.message });\n        }\n      },\n\n      // Clear messages (for current conversation)\n      clearMessages: () => {\n        set({ messages: [], error: null });\n      },\n\n      // Clear error\n      clearError: () => {\n        set({ error: null });\n      },\n\n      // Toggle sidebar\n      toggleSidebar: () => {\n        set((state) => ({ sidebarOpen: !state.sidebarOpen }));\n      },\n\n      // Toggle upload modal\n      toggleUploadModal: () => {\n        set((state) => ({ uploadModalOpen: !state.uploadModalOpen }));\n      },\n\n      // Set loading state\n      setLoading: (isLoading) => {\n        set({ isLoading });\n      },\n\n      // Set typing state\n      setTyping: (isTyping) => {\n        set({ isTyping });\n      },\n    }),\n    {\n      name: 'comviva-chat-store',\n      partialize: (state) => ({\n        currentSessionId: state.currentSessionId,\n        messages: state.messages,\n        sidebarOpen: state.sidebarOpen,\n        conversations: state.conversations,\n      }),\n    }\n  )\n);\n\nexport default useChatStore;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}