{"ast":null,"code":"import axios from 'axios';\nconst API_BASE_URL = process.env.REACT_APP_API_URL || '';\nconst api = axios.create({\n  baseURL: `${API_BASE_URL}/api`,\n  timeout: 120000,\n  // 2 minutes for chat\n  headers: {\n    'Content-Type': 'application/json'\n  }\n});\n\n// Request interceptor for logging\napi.interceptors.request.use(config => {\n  var _config$method;\n  console.log(`API Request: ${(_config$method = config.method) === null || _config$method === void 0 ? void 0 : _config$method.toUpperCase()} ${config.url}`);\n  return config;\n}, error => {\n  console.error('API Request Error:', error);\n  return Promise.reject(error);\n});\n\n// Response interceptor for error handling\napi.interceptors.response.use(response => {\n  return response;\n}, error => {\n  var _error$response;\n  console.error('API Response Error:', error);\n  if (((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status) === 500) {\n    console.error('Server Error:', error.response.data);\n  } else if (error.code === 'ECONNABORTED') {\n    console.error('Request timeout');\n  } else if (!error.response) {\n    console.error('Network error - server might be down');\n  }\n  return Promise.reject(error);\n});\nexport const chatAPI = {\n  // Send a message and get response\n  sendMessage: async (message, sessionId = null, stream = false, useInternetSearch = false) => {\n    try {\n      if (stream) {\n        // Return a stream for server-sent events\n        const response = await fetch(`/api/chat`, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json'\n          },\n          body: JSON.stringify({\n            message,\n            session_id: sessionId,\n            stream: true\n          })\n        });\n        if (!response.ok) {\n          throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        return response;\n      } else {\n        const response = await api.post('/chat', {\n          message,\n          session_id: sessionId,\n          stream: false\n        });\n        return response.data;\n      }\n    } catch (error) {\n      var _error$response2, _error$response2$data;\n      throw new Error(((_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : (_error$response2$data = _error$response2.data) === null || _error$response2$data === void 0 ? void 0 : _error$response2$data.error) || 'Failed to send message');\n    }\n  },\n  // Process streaming response\n  processStream: async function* (response, onChunk = null, onComplete = null, onError = null) {\n    try {\n      const reader = response.body.getReader();\n      const decoder = new TextDecoder();\n      let buffer = '';\n      while (true) {\n        const {\n          done,\n          value\n        } = await reader.read();\n        if (done) break;\n        buffer += decoder.decode(value, {\n          stream: true\n        });\n        const lines = buffer.split('\\n');\n        buffer = lines.pop(); // Keep the incomplete line in buffer\n\n        for (const line of lines) {\n          if (line.startsWith('data: ')) {\n            try {\n              const data = JSON.parse(line.slice(6));\n              if (data.type === 'chunk' && data.content) {\n                if (onChunk) onChunk(data.content);\n                yield data.content;\n              } else if (data.type === 'complete') {\n                if (onComplete) onComplete(data);\n                return data;\n              } else if (data.type === 'error') {\n                if (onError) onError(data.content);\n                throw new Error(data.content);\n              }\n            } catch (parseError) {\n              console.warn('Failed to parse streaming data:', line);\n            }\n          }\n        }\n      }\n    } catch (error) {\n      if (onError) onError(error.message);\n      throw error;\n    }\n  },\n  // Get conversation history\n  getConversationHistory: async sessionId => {\n    try {\n      const response = await api.get(`/conversations/${sessionId}`);\n      return response.data;\n    } catch (error) {\n      var _error$response3, _error$response3$data;\n      throw new Error(((_error$response3 = error.response) === null || _error$response3 === void 0 ? void 0 : (_error$response3$data = _error$response3.data) === null || _error$response3$data === void 0 ? void 0 : _error$response3$data.error) || 'Failed to get conversation history');\n    }\n  },\n  // Get all conversations\n  getAllConversations: async () => {\n    try {\n      const response = await api.get('/conversations');\n      return response.data;\n    } catch (error) {\n      var _error$response4, _error$response4$data;\n      throw new Error(((_error$response4 = error.response) === null || _error$response4 === void 0 ? void 0 : (_error$response4$data = _error$response4.data) === null || _error$response4$data === void 0 ? void 0 : _error$response4$data.error) || 'Failed to get conversations');\n    }\n  },\n  // Delete a conversation\n  deleteConversation: async sessionId => {\n    try {\n      const response = await api.delete(`/conversations/${sessionId}`);\n      return response.data;\n    } catch (error) {\n      var _error$response5, _error$response5$data;\n      throw new Error(((_error$response5 = error.response) === null || _error$response5 === void 0 ? void 0 : (_error$response5$data = _error$response5.data) === null || _error$response5$data === void 0 ? void 0 : _error$response5$data.error) || 'Failed to delete conversation');\n    }\n  },\n  // Upload a file\n  uploadFile: async (file, onProgress = null) => {\n    try {\n      const formData = new FormData();\n      formData.append('file', file);\n      const response = await api.post('/upload', formData, {\n        headers: {\n          'Content-Type': 'multipart/form-data'\n        },\n        onUploadProgress: progressEvent => {\n          if (onProgress && progressEvent.total) {\n            const percentCompleted = Math.round(progressEvent.loaded * 100 / progressEvent.total);\n            onProgress(percentCompleted);\n          }\n        }\n      });\n      return response.data;\n    } catch (error) {\n      var _error$response6, _error$response6$data;\n      throw new Error(((_error$response6 = error.response) === null || _error$response6 === void 0 ? void 0 : (_error$response6$data = _error$response6.data) === null || _error$response6$data === void 0 ? void 0 : _error$response6$data.error) || 'Failed to upload file');\n    }\n  },\n  // Upload document for chat\n  uploadChatDocument: async (sessionId, formData) => {\n    try {\n      const response = await api.post(`/chat/upload?session_id=${sessionId}`, formData, {\n        headers: {\n          'Content-Type': 'multipart/form-data'\n        }\n      });\n      return response.data;\n    } catch (error) {\n      var _error$response7, _error$response7$data;\n      throw new Error(((_error$response7 = error.response) === null || _error$response7 === void 0 ? void 0 : (_error$response7$data = _error$response7.data) === null || _error$response7$data === void 0 ? void 0 : _error$response7$data.detail) || 'Failed to upload chat document');\n    }\n  },\n  // Get chat documents\n  getChatDocuments: async sessionId => {\n    try {\n      const response = await api.get(`/chat/documents/${sessionId}`);\n      return response.data;\n    } catch (error) {\n      var _error$response8, _error$response8$data;\n      throw new Error(((_error$response8 = error.response) === null || _error$response8 === void 0 ? void 0 : (_error$response8$data = _error$response8.data) === null || _error$response8$data === void 0 ? void 0 : _error$response8$data.detail) || 'Failed to get chat documents');\n    }\n  },\n  // Remove chat document\n  removeChatDocument: async (sessionId, docId) => {\n    try {\n      const response = await api.delete(`/chat/documents/${sessionId}/${docId}`);\n      return response.data;\n    } catch (error) {\n      var _error$response9, _error$response9$data;\n      throw new Error(((_error$response9 = error.response) === null || _error$response9 === void 0 ? void 0 : (_error$response9$data = _error$response9.data) === null || _error$response9$data === void 0 ? void 0 : _error$response9$data.detail) || 'Failed to remove chat document');\n    }\n  },\n  // Get system health\n  getHealth: async () => {\n    try {\n      const response = await api.get('/health');\n      return response.data;\n    } catch (error) {\n      var _error$response0, _error$response0$data;\n      throw new Error(((_error$response0 = error.response) === null || _error$response0 === void 0 ? void 0 : (_error$response0$data = _error$response0.data) === null || _error$response0$data === void 0 ? void 0 : _error$response0$data.error) || 'Failed to get system health');\n    }\n  },\n  // Get processing status\n  getProcessingStatus: async processingId => {\n    try {\n      const response = await api.get(`/processing/${processingId}`);\n      return response.data;\n    } catch (error) {\n      var _error$response1, _error$response1$data;\n      throw new Error(((_error$response1 = error.response) === null || _error$response1 === void 0 ? void 0 : (_error$response1$data = _error$response1.data) === null || _error$response1$data === void 0 ? void 0 : _error$response1$data.error) || 'Failed to get processing status');\n    }\n  }\n};\nexport const systemAPI = {\n  // Check if backend is available\n  checkBackendStatus: async () => {\n    try {\n      const response = await api.get('/health');\n      return {\n        available: true,\n        data: response.data\n      };\n    } catch (error) {\n      return {\n        available: false,\n        error: error.message\n      };\n    }\n  },\n  // Get system statistics (if available)\n  getStats: async () => {\n    try {\n      const response = await api.get('/stats');\n      return response.data;\n    } catch (error) {\n      // Stats endpoint might not be available\n      console.warn('Stats endpoint not available:', error.message);\n      return null;\n    }\n  }\n};\nexport default api;","map":{"version":3,"names":["axios","API_BASE_URL","process","env","REACT_APP_API_URL","api","create","baseURL","timeout","headers","interceptors","request","use","config","_config$method","console","log","method","toUpperCase","url","error","Promise","reject","response","_error$response","status","data","code","chatAPI","sendMessage","message","sessionId","stream","useInternetSearch","fetch","body","JSON","stringify","session_id","ok","Error","post","_error$response2","_error$response2$data","processStream","onChunk","onComplete","onError","reader","getReader","decoder","TextDecoder","buffer","done","value","read","decode","lines","split","pop","line","startsWith","parse","slice","type","content","parseError","warn","getConversationHistory","get","_error$response3","_error$response3$data","getAllConversations","_error$response4","_error$response4$data","deleteConversation","delete","_error$response5","_error$response5$data","uploadFile","file","onProgress","formData","FormData","append","onUploadProgress","progressEvent","total","percentCompleted","Math","round","loaded","_error$response6","_error$response6$data","uploadChatDocument","_error$response7","_error$response7$data","detail","getChatDocuments","_error$response8","_error$response8$data","removeChatDocument","docId","_error$response9","_error$response9$data","getHealth","_error$response0","_error$response0$data","getProcessingStatus","processingId","_error$response1","_error$response1$data","systemAPI","checkBackendStatus","available","getStats"],"sources":["/home/im/Druthik/clean_rag/frontend/src/services/api.js"],"sourcesContent":["import axios from 'axios';\n\nconst API_BASE_URL = process.env.REACT_APP_API_URL || '';\n\nconst api = axios.create({\n  baseURL: `${API_BASE_URL}/api`,\n  timeout: 120000,  // 2 minutes for chat\n  headers: {\n    'Content-Type': 'application/json',\n  },\n});\n\n// Request interceptor for logging\napi.interceptors.request.use(\n  (config) => {\n    console.log(`API Request: ${config.method?.toUpperCase()} ${config.url}`);\n    return config;\n  },\n  (error) => {\n    console.error('API Request Error:', error);\n    return Promise.reject(error);\n  }\n);\n\n// Response interceptor for error handling\napi.interceptors.response.use(\n  (response) => {\n    return response;\n  },\n  (error) => {\n    console.error('API Response Error:', error);\n    \n    if (error.response?.status === 500) {\n      console.error('Server Error:', error.response.data);\n    } else if (error.code === 'ECONNABORTED') {\n      console.error('Request timeout');\n    } else if (!error.response) {\n      console.error('Network error - server might be down');\n    }\n    \n    return Promise.reject(error);\n  }\n);\n\nexport const chatAPI = {\n  // Send a message and get response\n  sendMessage: async (message, sessionId = null, stream = false, useInternetSearch = false) => {\n    try {\n      if (stream) {\n        // Return a stream for server-sent events\n        const response = await fetch(`/api/chat`, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n          },\n          body: JSON.stringify({\n            message,\n            session_id: sessionId,\n            stream: true,\n          }),\n        });\n\n        if (!response.ok) {\n          throw new Error(`HTTP error! status: ${response.status}`);\n        }\n\n        return response;\n      } else {\n        const response = await api.post('/chat', {\n          message,\n          session_id: sessionId,\n          stream: false,\n        });\n        return response.data;\n      }\n    } catch (error) {\n      throw new Error(error.response?.data?.error || 'Failed to send message');\n    }\n  },\n\n  // Process streaming response\n  processStream: async function* (response, onChunk = null, onComplete = null, onError = null) {\n    try {\n      const reader = response.body.getReader();\n      const decoder = new TextDecoder();\n      let buffer = '';\n\n      while (true) {\n        const { done, value } = await reader.read();\n        \n        if (done) break;\n\n        buffer += decoder.decode(value, { stream: true });\n        const lines = buffer.split('\\n');\n        buffer = lines.pop(); // Keep the incomplete line in buffer\n\n        for (const line of lines) {\n          if (line.startsWith('data: ')) {\n            try {\n              const data = JSON.parse(line.slice(6));\n              \n              if (data.type === 'chunk' && data.content) {\n                if (onChunk) onChunk(data.content);\n                yield data.content;\n              } else if (data.type === 'complete') {\n                if (onComplete) onComplete(data);\n                return data;\n              } else if (data.type === 'error') {\n                if (onError) onError(data.content);\n                throw new Error(data.content);\n              }\n            } catch (parseError) {\n              console.warn('Failed to parse streaming data:', line);\n            }\n          }\n        }\n      }\n    } catch (error) {\n      if (onError) onError(error.message);\n      throw error;\n    }\n  },\n\n  // Get conversation history\n  getConversationHistory: async (sessionId) => {\n    try {\n      const response = await api.get(`/conversations/${sessionId}`);\n      return response.data;\n    } catch (error) {\n      throw new Error(error.response?.data?.error || 'Failed to get conversation history');\n    }\n  },\n\n  // Get all conversations\n  getAllConversations: async () => {\n    try {\n      const response = await api.get('/conversations');\n      return response.data;\n    } catch (error) {\n      throw new Error(error.response?.data?.error || 'Failed to get conversations');\n    }\n  },\n\n  // Delete a conversation\n  deleteConversation: async (sessionId) => {\n    try {\n      const response = await api.delete(`/conversations/${sessionId}`);\n      return response.data;\n    } catch (error) {\n      throw new Error(error.response?.data?.error || 'Failed to delete conversation');\n    }\n  },\n\n  // Upload a file\n  uploadFile: async (file, onProgress = null) => {\n    try {\n      const formData = new FormData();\n      formData.append('file', file);\n\n      const response = await api.post('/upload', formData, {\n        headers: {\n          'Content-Type': 'multipart/form-data',\n        },\n        onUploadProgress: (progressEvent) => {\n          if (onProgress && progressEvent.total) {\n            const percentCompleted = Math.round(\n              (progressEvent.loaded * 100) / progressEvent.total\n            );\n            onProgress(percentCompleted);\n          }\n        },\n      });\n      \n      return response.data;\n    } catch (error) {\n      throw new Error(error.response?.data?.error || 'Failed to upload file');\n    }\n  },\n\n  // Upload document for chat\n  uploadChatDocument: async (sessionId, formData) => {\n    try {\n      const response = await api.post(`/chat/upload?session_id=${sessionId}`, formData, {\n        headers: {\n          'Content-Type': 'multipart/form-data',\n        },\n      });\n      return response.data;\n    } catch (error) {\n      throw new Error(error.response?.data?.detail || 'Failed to upload chat document');\n    }\n  },\n\n  // Get chat documents\n  getChatDocuments: async (sessionId) => {\n    try {\n      const response = await api.get(`/chat/documents/${sessionId}`);\n      return response.data;\n    } catch (error) {\n      throw new Error(error.response?.data?.detail || 'Failed to get chat documents');\n    }\n  },\n\n  // Remove chat document\n  removeChatDocument: async (sessionId, docId) => {\n    try {\n      const response = await api.delete(`/chat/documents/${sessionId}/${docId}`);\n      return response.data;\n    } catch (error) {\n      throw new Error(error.response?.data?.detail || 'Failed to remove chat document');\n    }\n  },\n\n  // Get system health\n  getHealth: async () => {\n    try {\n      const response = await api.get('/health');\n      return response.data;\n    } catch (error) {\n      throw new Error(error.response?.data?.error || 'Failed to get system health');\n    }\n  },\n\n  // Get processing status\n  getProcessingStatus: async (processingId) => {\n    try {\n      const response = await api.get(`/processing/${processingId}`);\n      return response.data;\n    } catch (error) {\n      throw new Error(error.response?.data?.error || 'Failed to get processing status');\n    }\n  },\n};\n\nexport const systemAPI = {\n  // Check if backend is available\n  checkBackendStatus: async () => {\n    try {\n      const response = await api.get('/health');\n      return { \n        available: true, \n        data: response.data \n      };\n    } catch (error) {\n      return { \n        available: false, \n        error: error.message \n      };\n    }\n  },\n\n  // Get system statistics (if available)\n  getStats: async () => {\n    try {\n      const response = await api.get('/stats');\n      return response.data;\n    } catch (error) {\n      // Stats endpoint might not be available\n      console.warn('Stats endpoint not available:', error.message);\n      return null;\n    }\n  },\n};\n\nexport default api;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}