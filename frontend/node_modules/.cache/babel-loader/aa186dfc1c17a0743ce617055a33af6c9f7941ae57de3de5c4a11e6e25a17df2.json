{"ast":null,"code":"import { create } from 'zustand';\nimport { persist } from 'zustand/middleware';\nimport { chatAPI } from '../services/api';\nconst useChatStore = create(persist((set, get) => ({\n  // Current conversation state\n  currentSessionId: null,\n  messages: [],\n  isLoading: false,\n  isTyping: false,\n  error: null,\n  // Conversation management\n  conversations: [],\n  isLoadingConversations: false,\n  // UI state\n  sidebarOpen: true,\n  uploadModalOpen: false,\n  settingsModalOpen: false,\n  // Actions\n  setCurrentSession: async sessionId => {\n    const {\n      currentSessionId\n    } = get();\n\n    // Don't reload if it's the same session\n    if (currentSessionId === sessionId) {\n      return;\n    }\n\n    // Load conversation history if sessionId exists\n    if (sessionId) {\n      set({\n        currentSessionId: sessionId,\n        error: null\n      });\n      await get().loadConversationHistory(sessionId);\n    } else {\n      // Only clear messages for new conversation\n      set({\n        currentSessionId: sessionId,\n        messages: [],\n        error: null\n      });\n    }\n  },\n  // Send a message with streaming support\n  sendMessage: async (messageText, streaming = false) => {\n    const {\n      currentSessionId\n    } = get();\n    set({\n      isLoading: true,\n      error: null\n    });\n\n    // Add user message immediately to UI\n    const userMessage = {\n      id: Date.now().toString(),\n      type: 'user',\n      content: messageText,\n      timestamp: new Date().toISOString()\n    };\n    set(state => ({\n      messages: [...state.messages, userMessage],\n      isTyping: true\n    }));\n    try {\n      if (streaming) {\n        // Streaming response\n        const response = await chatAPI.sendMessage(messageText, currentSessionId, true);\n\n        // Create initial bot message\n        const botMessageId = (Date.now() + 1).toString();\n        const botMessage = {\n          id: botMessageId,\n          type: 'bot',\n          content: '',\n          timestamp: new Date().toISOString(),\n          sources: [],\n          isStreaming: true\n        };\n        set(state => ({\n          messages: [...state.messages, botMessage],\n          isLoading: false,\n          isTyping: false\n        }));\n\n        // Process streaming response\n        let fullContent = '';\n        const streamGenerator = chatAPI.processStream(response, chunk => {\n          fullContent += chunk;\n          // Update the message in real-time\n          set(state => ({\n            messages: state.messages.map(msg => msg.id === botMessageId ? {\n              ...msg,\n              content: fullContent\n            } : msg)\n          }));\n        }, completionData => {\n          // Final update with metadata\n          set(state => ({\n            messages: state.messages.map(msg => msg.id === botMessageId ? {\n              ...msg,\n              content: fullContent,\n              sources: completionData.sources || [],\n              timestamp: completionData.timestamp,\n              isStreaming: false\n            } : msg),\n            currentSessionId: completionData.session_id\n          }));\n\n          // Refresh conversations list\n          get().loadConversations();\n        }, error => {\n          console.error('Streaming error:', error);\n          set(state => ({\n            messages: state.messages.map(msg => msg.id === botMessageId ? {\n              ...msg,\n              type: 'error',\n              content: error,\n              isStreaming: false\n            } : msg),\n            error\n          }));\n        });\n\n        // Consume the generator\n        try {\n          // eslint-disable-next-line no-unused-vars\n          for await (const _ of streamGenerator) {\n            // Chunks are processed in the onChunk callback\n          }\n        } catch (streamError) {\n          console.error('Stream processing error:', streamError);\n        }\n      } else {\n        // Non-streaming response (fallback)\n        const response = await chatAPI.sendMessage(messageText, currentSessionId, false);\n        const botMessage = {\n          id: (Date.now() + 1).toString(),\n          type: 'bot',\n          content: response.response,\n          timestamp: response.timestamp || new Date().toISOString(),\n          sources: response.sources || [],\n          session_id: response.session_id\n        };\n        set(state => ({\n          messages: [...state.messages, botMessage],\n          currentSessionId: response.session_id,\n          isLoading: false,\n          isTyping: false\n        }));\n        get().loadConversations();\n      }\n    } catch (error) {\n      console.error('Failed to send message:', error);\n\n      // Add error message\n      const errorMessage = {\n        id: (Date.now() + 1).toString(),\n        type: 'error',\n        content: error.message || 'Failed to get response. Please try again.',\n        timestamp: new Date().toISOString()\n      };\n      set(state => ({\n        messages: [...state.messages, errorMessage],\n        isLoading: false,\n        isTyping: false,\n        error: error.message\n      }));\n    }\n  },\n  // Load conversation history\n  loadConversationHistory: async sessionId => {\n    if (!sessionId) return;\n    set({\n      isLoading: true,\n      error: null\n    });\n    try {\n      const history = await chatAPI.getConversationHistory(sessionId);\n      console.log('Loaded history for session:', sessionId, history);\n      console.log('First entry structure:', history[0]);\n\n      // Convert history to message format\n      const messages = [];\n      if (history && Array.isArray(history)) {\n        history.forEach(entry => {\n          if (entry.query) {\n            messages.push({\n              id: `${entry.id}-user`,\n              type: 'user',\n              content: entry.query,\n              timestamp: entry.timestamp\n            });\n          }\n          if (entry.response) {\n            messages.push({\n              id: `${entry.id}-bot`,\n              type: 'bot',\n              content: entry.response,\n              timestamp: entry.timestamp,\n              sources: entry.sources || []\n            });\n          }\n        });\n      }\n      console.log('Converted messages:', messages);\n      set({\n        messages,\n        isLoading: false\n      });\n    } catch (error) {\n      console.error('Failed to load conversation history:', error);\n      set({\n        isLoading: false,\n        error: error.message\n      });\n    }\n  },\n  // Load all conversations\n  loadConversations: async () => {\n    set({\n      isLoadingConversations: true\n    });\n    try {\n      const conversations = await chatAPI.getAllConversations();\n      set({\n        conversations: conversations || [],\n        isLoadingConversations: false\n      });\n    } catch (error) {\n      console.error('Failed to load conversations:', error);\n      set({\n        conversations: [],\n        isLoadingConversations: false\n      });\n    }\n  },\n  // Start new conversation\n  startNewConversation: () => {\n    const newSessionId = `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    set({\n      currentSessionId: newSessionId,\n      messages: [],\n      error: null\n    });\n  },\n  // Delete conversation\n  deleteConversation: async sessionId => {\n    try {\n      await chatAPI.deleteConversation(sessionId);\n\n      // Remove from conversations list\n      set(state => ({\n        conversations: state.conversations.filter(conv => conv.session_id !== sessionId)\n      }));\n\n      // If it was the current conversation, start new one\n      const {\n        currentSessionId\n      } = get();\n      if (currentSessionId === sessionId) {\n        get().startNewConversation();\n      }\n    } catch (error) {\n      console.error('Failed to delete conversation:', error);\n      set({\n        error: error.message\n      });\n    }\n  },\n  // Rename conversation\n  renameConversation: async (sessionId, newTitle) => {\n    try {\n      // Update locally first for immediate feedback\n      set(state => ({\n        conversations: state.conversations.map(conv => conv.session_id === sessionId ? {\n          ...conv,\n          title: newTitle\n        } : conv)\n      }));\n\n      // TODO: Add API call when backend supports it\n      // await chatAPI.renameConversation(sessionId, newTitle);\n    } catch (error) {\n      console.error('Failed to rename conversation:', error);\n      // Revert on error\n      get().loadConversations();\n      set({\n        error: error.message\n      });\n    }\n  },\n  // Clear messages (for current conversation)\n  clearMessages: () => {\n    set({\n      messages: [],\n      error: null\n    });\n  },\n  // Clear error\n  clearError: () => {\n    set({\n      error: null\n    });\n  },\n  // Toggle sidebar\n  toggleSidebar: () => {\n    set(state => ({\n      sidebarOpen: !state.sidebarOpen\n    }));\n  },\n  // Toggle upload modal\n  toggleUploadModal: () => {\n    set(state => ({\n      uploadModalOpen: !state.uploadModalOpen\n    }));\n  },\n  // Toggle settings modal\n  toggleSettingsModal: () => {\n    set(state => ({\n      settingsModalOpen: !state.settingsModalOpen\n    }));\n  },\n  // Set loading state\n  setLoading: isLoading => {\n    set({\n      isLoading\n    });\n  },\n  // Set typing state\n  setTyping: isTyping => {\n    set({\n      isTyping\n    });\n  }\n}), {\n  name: 'comviva-chat-store',\n  partialize: state => ({\n    currentSessionId: state.currentSessionId,\n    messages: state.messages,\n    sidebarOpen: state.sidebarOpen,\n    conversations: state.conversations\n  })\n}));\nexport default useChatStore;","map":{"version":3,"names":["create","persist","chatAPI","useChatStore","set","get","currentSessionId","messages","isLoading","isTyping","error","conversations","isLoadingConversations","sidebarOpen","uploadModalOpen","settingsModalOpen","setCurrentSession","sessionId","loadConversationHistory","sendMessage","messageText","streaming","userMessage","id","Date","now","toString","type","content","timestamp","toISOString","state","response","botMessageId","botMessage","sources","isStreaming","fullContent","streamGenerator","processStream","chunk","map","msg","completionData","session_id","loadConversations","console","_","streamError","errorMessage","message","history","getConversationHistory","log","Array","isArray","forEach","entry","query","push","getAllConversations","startNewConversation","newSessionId","Math","random","substr","deleteConversation","filter","conv","renameConversation","newTitle","title","clearMessages","clearError","toggleSidebar","toggleUploadModal","toggleSettingsModal","setLoading","setTyping","name","partialize"],"sources":["/home/im/Druthik/clean_rag/frontend/src/stores/chatStore.js"],"sourcesContent":["import { create } from 'zustand';\nimport { persist } from 'zustand/middleware';\nimport { chatAPI } from '../services/api';\n\nconst useChatStore = create(\n  persist(\n    (set, get) => ({\n      // Current conversation state\n      currentSessionId: null,\n      messages: [],\n      isLoading: false,\n      isTyping: false,\n      error: null,\n\n      // Conversation management\n      conversations: [],\n      isLoadingConversations: false,\n\n      // UI state\n      sidebarOpen: true,\n      uploadModalOpen: false,\n      settingsModalOpen: false,\n\n      // Actions\n      setCurrentSession: async (sessionId) => {\n        const { currentSessionId } = get();\n        \n        // Don't reload if it's the same session\n        if (currentSessionId === sessionId) {\n          return;\n        }\n        \n        // Load conversation history if sessionId exists\n        if (sessionId) {\n          set({ currentSessionId: sessionId, error: null });\n          await get().loadConversationHistory(sessionId);\n        } else {\n          // Only clear messages for new conversation\n          set({ currentSessionId: sessionId, messages: [], error: null });\n        }\n      },\n\n      // Send a message with streaming support\n      sendMessage: async (messageText, streaming = false) => {\n        const { currentSessionId } = get();\n        \n        set({ isLoading: true, error: null });\n\n        // Add user message immediately to UI\n        const userMessage = {\n          id: Date.now().toString(),\n          type: 'user',\n          content: messageText,\n          timestamp: new Date().toISOString(),\n        };\n\n        set((state) => ({\n          messages: [...state.messages, userMessage],\n          isTyping: true,\n        }));\n\n        try {\n          if (streaming) {\n            // Streaming response\n            const response = await chatAPI.sendMessage(messageText, currentSessionId, true);\n            \n            // Create initial bot message\n            const botMessageId = (Date.now() + 1).toString();\n            const botMessage = {\n              id: botMessageId,\n              type: 'bot',\n              content: '',\n              timestamp: new Date().toISOString(),\n              sources: [],\n              isStreaming: true,\n            };\n\n            set((state) => ({\n              messages: [...state.messages, botMessage],\n              isLoading: false,\n              isTyping: false,\n            }));\n\n            // Process streaming response\n            let fullContent = '';\n            const streamGenerator = chatAPI.processStream(\n              response,\n              (chunk) => {\n                fullContent += chunk;\n                // Update the message in real-time\n                set((state) => ({\n                  messages: state.messages.map((msg) =>\n                    msg.id === botMessageId\n                      ? { ...msg, content: fullContent }\n                      : msg\n                  ),\n                }));\n              },\n              (completionData) => {\n                // Final update with metadata\n                set((state) => ({\n                  messages: state.messages.map((msg) =>\n                    msg.id === botMessageId\n                      ? {\n                          ...msg,\n                          content: fullContent,\n                          sources: completionData.sources || [],\n                          timestamp: completionData.timestamp,\n                          isStreaming: false,\n                        }\n                      : msg\n                  ),\n                  currentSessionId: completionData.session_id,\n                }));\n\n                // Refresh conversations list\n                get().loadConversations();\n              },\n              (error) => {\n                console.error('Streaming error:', error);\n                set((state) => ({\n                  messages: state.messages.map((msg) =>\n                    msg.id === botMessageId\n                      ? { ...msg, type: 'error', content: error, isStreaming: false }\n                      : msg\n                  ),\n                  error,\n                }));\n              }\n            );\n\n            // Consume the generator\n            try {\n              // eslint-disable-next-line no-unused-vars\n              for await (const _ of streamGenerator) {\n                // Chunks are processed in the onChunk callback\n              }\n            } catch (streamError) {\n              console.error('Stream processing error:', streamError);\n            }\n\n          } else {\n            // Non-streaming response (fallback)\n            const response = await chatAPI.sendMessage(messageText, currentSessionId, false);\n            \n            const botMessage = {\n              id: (Date.now() + 1).toString(),\n              type: 'bot',\n              content: response.response,\n              timestamp: response.timestamp || new Date().toISOString(),\n              sources: response.sources || [],\n              session_id: response.session_id,\n            };\n\n            set((state) => ({\n              messages: [...state.messages, botMessage],\n              currentSessionId: response.session_id,\n              isLoading: false,\n              isTyping: false,\n            }));\n\n            get().loadConversations();\n          }\n\n        } catch (error) {\n          console.error('Failed to send message:', error);\n          \n          // Add error message\n          const errorMessage = {\n            id: (Date.now() + 1).toString(),\n            type: 'error',\n            content: error.message || 'Failed to get response. Please try again.',\n            timestamp: new Date().toISOString(),\n          };\n\n          set((state) => ({\n            messages: [...state.messages, errorMessage],\n            isLoading: false,\n            isTyping: false,\n            error: error.message,\n          }));\n        }\n      },\n\n      // Load conversation history\n      loadConversationHistory: async (sessionId) => {\n        if (!sessionId) return;\n\n        set({ isLoading: true, error: null });\n\n        try {\n          const history = await chatAPI.getConversationHistory(sessionId);\n          console.log('Loaded history for session:', sessionId, history);\n          console.log('First entry structure:', history[0]);\n          \n          // Convert history to message format\n          const messages = [];\n          if (history && Array.isArray(history)) {\n            history.forEach((entry) => {\n              if (entry.query) {\n                messages.push({\n                  id: `${entry.id}-user`,\n                  type: 'user',\n                  content: entry.query,\n                  timestamp: entry.timestamp,\n                });\n              }\n              if (entry.response) {\n                messages.push({\n                  id: `${entry.id}-bot`,\n                  type: 'bot',\n                  content: entry.response,\n                  timestamp: entry.timestamp,\n                  sources: entry.sources || [],\n                });\n              }\n            });\n          }\n          console.log('Converted messages:', messages);\n\n          set({\n            messages,\n            isLoading: false,\n          });\n\n        } catch (error) {\n          console.error('Failed to load conversation history:', error);\n          set({\n            isLoading: false,\n            error: error.message,\n          });\n        }\n      },\n\n      // Load all conversations\n      loadConversations: async () => {\n        set({ isLoadingConversations: true });\n\n        try {\n          const conversations = await chatAPI.getAllConversations();\n          set({\n            conversations: conversations || [],\n            isLoadingConversations: false,\n          });\n        } catch (error) {\n          console.error('Failed to load conversations:', error);\n          set({\n            conversations: [],\n            isLoadingConversations: false,\n          });\n        }\n      },\n\n      // Start new conversation\n      startNewConversation: () => {\n        const newSessionId = `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n        set({\n          currentSessionId: newSessionId,\n          messages: [],\n          error: null,\n        });\n      },\n\n      // Delete conversation\n      deleteConversation: async (sessionId) => {\n        try {\n          await chatAPI.deleteConversation(sessionId);\n          \n          // Remove from conversations list\n          set((state) => ({\n            conversations: state.conversations.filter(\n              (conv) => conv.session_id !== sessionId\n            ),\n          }));\n\n          // If it was the current conversation, start new one\n          const { currentSessionId } = get();\n          if (currentSessionId === sessionId) {\n            get().startNewConversation();\n          }\n\n        } catch (error) {\n          console.error('Failed to delete conversation:', error);\n          set({ error: error.message });\n        }\n      },\n\n      // Rename conversation\n      renameConversation: async (sessionId, newTitle) => {\n        try {\n          // Update locally first for immediate feedback\n          set((state) => ({\n            conversations: state.conversations.map((conv) =>\n              conv.session_id === sessionId\n                ? { ...conv, title: newTitle }\n                : conv\n            ),\n          }));\n\n          // TODO: Add API call when backend supports it\n          // await chatAPI.renameConversation(sessionId, newTitle);\n          \n        } catch (error) {\n          console.error('Failed to rename conversation:', error);\n          // Revert on error\n          get().loadConversations();\n          set({ error: error.message });\n        }\n      },\n\n      // Clear messages (for current conversation)\n      clearMessages: () => {\n        set({ messages: [], error: null });\n      },\n\n      // Clear error\n      clearError: () => {\n        set({ error: null });\n      },\n\n      // Toggle sidebar\n      toggleSidebar: () => {\n        set((state) => ({ sidebarOpen: !state.sidebarOpen }));\n      },\n\n      // Toggle upload modal\n      toggleUploadModal: () => {\n        set((state) => ({ uploadModalOpen: !state.uploadModalOpen }));\n      },\n\n      // Toggle settings modal\n      toggleSettingsModal: () => {\n        set((state) => ({ settingsModalOpen: !state.settingsModalOpen }));\n      },\n\n      // Set loading state\n      setLoading: (isLoading) => {\n        set({ isLoading });\n      },\n\n      // Set typing state\n      setTyping: (isTyping) => {\n        set({ isTyping });\n      },\n    }),\n    {\n      name: 'comviva-chat-store',\n      partialize: (state) => ({\n        currentSessionId: state.currentSessionId,\n        messages: state.messages,\n        sidebarOpen: state.sidebarOpen,\n        conversations: state.conversations,\n      }),\n    }\n  )\n);\n\nexport default useChatStore;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}