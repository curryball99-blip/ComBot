{"ast":null,"code":"import axios from 'axios';\nconst API_BASE_URL = process.env.REACT_APP_API_URL || '';\nconst api = axios.create({\n  baseURL: `${API_BASE_URL}/api`,\n  timeout: 120000,\n  // 2 minutes for chat\n  headers: {\n    'Content-Type': 'application/json'\n  }\n});\n\n// Request interceptor for logging\napi.interceptors.request.use(config => {\n  var _config$method;\n  console.log(`API Request: ${(_config$method = config.method) === null || _config$method === void 0 ? void 0 : _config$method.toUpperCase()} ${config.url}`);\n  return config;\n}, error => {\n  console.error('API Request Error:', error);\n  return Promise.reject(error);\n});\n\n// Response interceptor for error handling\napi.interceptors.response.use(response => {\n  return response;\n}, error => {\n  var _error$response;\n  console.error('API Response Error:', error);\n  if (((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status) === 500) {\n    console.error('Server Error:', error.response.data);\n  } else if (error.code === 'ECONNABORTED') {\n    console.error('Request timeout');\n  } else if (!error.response) {\n    console.error('Network error - server might be down');\n  }\n  return Promise.reject(error);\n});\nexport const chatAPI = {\n  // Send a message and get response\n  sendMessage: async (message, sessionId = null, stream = false) => {\n    try {\n      if (stream) {\n        // Return a stream for server-sent events\n        const response = await fetch(`${API_BASE_URL}/api/chat`, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json'\n          },\n          body: JSON.stringify({\n            message,\n            session_id: sessionId,\n            stream: true\n          })\n        });\n        if (!response.ok) {\n          throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        return response;\n      } else {\n        const response = await api.post('/chat', {\n          message,\n          session_id: sessionId,\n          stream: false\n        });\n        return response.data;\n      }\n    } catch (error) {\n      var _error$response2, _error$response2$data;\n      throw new Error(((_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : (_error$response2$data = _error$response2.data) === null || _error$response2$data === void 0 ? void 0 : _error$response2$data.error) || 'Failed to send message');\n    }\n  },\n  // Process streaming response\n  processStream: async function* (response, onChunk = null, onComplete = null, onError = null) {\n    try {\n      const reader = response.body.getReader();\n      const decoder = new TextDecoder();\n      let buffer = '';\n      while (true) {\n        const {\n          done,\n          value\n        } = await reader.read();\n        if (done) break;\n        buffer += decoder.decode(value, {\n          stream: true\n        });\n        const lines = buffer.split('\\n');\n        buffer = lines.pop(); // Keep the incomplete line in buffer\n\n        for (const line of lines) {\n          if (line.startsWith('data: ')) {\n            try {\n              const data = JSON.parse(line.slice(6));\n              if (data.type === 'chunk' && data.content) {\n                if (onChunk) onChunk(data.content);\n                yield data.content;\n              } else if (data.type === 'complete') {\n                if (onComplete) onComplete(data);\n                return data;\n              } else if (data.type === 'error') {\n                if (onError) onError(data.content);\n                throw new Error(data.content);\n              }\n            } catch (parseError) {\n              console.warn('Failed to parse streaming data:', line);\n            }\n          }\n        }\n      }\n    } catch (error) {\n      if (onError) onError(error.message);\n      throw error;\n    }\n  },\n  // Get conversation history\n  getConversationHistory: async sessionId => {\n    try {\n      const response = await api.get(`/conversations/${sessionId}`);\n      return response.data;\n    } catch (error) {\n      var _error$response3, _error$response3$data;\n      throw new Error(((_error$response3 = error.response) === null || _error$response3 === void 0 ? void 0 : (_error$response3$data = _error$response3.data) === null || _error$response3$data === void 0 ? void 0 : _error$response3$data.error) || 'Failed to get conversation history');\n    }\n  },\n  // Get all conversations\n  getAllConversations: async () => {\n    try {\n      const response = await api.get('/conversations');\n      return response.data;\n    } catch (error) {\n      var _error$response4, _error$response4$data;\n      throw new Error(((_error$response4 = error.response) === null || _error$response4 === void 0 ? void 0 : (_error$response4$data = _error$response4.data) === null || _error$response4$data === void 0 ? void 0 : _error$response4$data.error) || 'Failed to get conversations');\n    }\n  },\n  // Delete a conversation\n  deleteConversation: async sessionId => {\n    try {\n      const response = await api.delete(`/conversations/${sessionId}`);\n      return response.data;\n    } catch (error) {\n      var _error$response5, _error$response5$data;\n      throw new Error(((_error$response5 = error.response) === null || _error$response5 === void 0 ? void 0 : (_error$response5$data = _error$response5.data) === null || _error$response5$data === void 0 ? void 0 : _error$response5$data.error) || 'Failed to delete conversation');\n    }\n  },\n  // Upload a file\n  uploadFile: async (file, onProgress = null) => {\n    try {\n      const formData = new FormData();\n      formData.append('file', file);\n      const response = await api.post('/upload', formData, {\n        headers: {\n          'Content-Type': 'multipart/form-data'\n        },\n        onUploadProgress: progressEvent => {\n          if (onProgress && progressEvent.total) {\n            const percentCompleted = Math.round(progressEvent.loaded * 100 / progressEvent.total);\n            onProgress(percentCompleted);\n          }\n        }\n      });\n      return response.data;\n    } catch (error) {\n      var _error$response6, _error$response6$data;\n      throw new Error(((_error$response6 = error.response) === null || _error$response6 === void 0 ? void 0 : (_error$response6$data = _error$response6.data) === null || _error$response6$data === void 0 ? void 0 : _error$response6$data.error) || 'Failed to upload file');\n    }\n  },\n  // Get system health\n  getHealth: async () => {\n    try {\n      const response = await api.get('/health');\n      return response.data;\n    } catch (error) {\n      var _error$response7, _error$response7$data;\n      throw new Error(((_error$response7 = error.response) === null || _error$response7 === void 0 ? void 0 : (_error$response7$data = _error$response7.data) === null || _error$response7$data === void 0 ? void 0 : _error$response7$data.error) || 'Failed to get system health');\n    }\n  },\n  // Get processing status\n  getProcessingStatus: async processingId => {\n    try {\n      const response = await api.get(`/processing/${processingId}`);\n      return response.data;\n    } catch (error) {\n      var _error$response8, _error$response8$data;\n      throw new Error(((_error$response8 = error.response) === null || _error$response8 === void 0 ? void 0 : (_error$response8$data = _error$response8.data) === null || _error$response8$data === void 0 ? void 0 : _error$response8$data.error) || 'Failed to get processing status');\n    }\n  }\n};\nexport const systemAPI = {\n  // Check if backend is available\n  checkBackendStatus: async () => {\n    try {\n      const response = await api.get('/health');\n      return {\n        available: true,\n        data: response.data\n      };\n    } catch (error) {\n      return {\n        available: false,\n        error: error.message\n      };\n    }\n  },\n  // Get system statistics (if available)\n  getStats: async () => {\n    try {\n      const response = await api.get('/stats');\n      return response.data;\n    } catch (error) {\n      // Stats endpoint might not be available\n      console.warn('Stats endpoint not available:', error.message);\n      return null;\n    }\n  }\n};\nexport default api;","map":{"version":3,"names":["axios","API_BASE_URL","process","env","REACT_APP_API_URL","api","create","baseURL","timeout","headers","interceptors","request","use","config","_config$method","console","log","method","toUpperCase","url","error","Promise","reject","response","_error$response","status","data","code","chatAPI","sendMessage","message","sessionId","stream","fetch","body","JSON","stringify","session_id","ok","Error","post","_error$response2","_error$response2$data","processStream","onChunk","onComplete","onError","reader","getReader","decoder","TextDecoder","buffer","done","value","read","decode","lines","split","pop","line","startsWith","parse","slice","type","content","parseError","warn","getConversationHistory","get","_error$response3","_error$response3$data","getAllConversations","_error$response4","_error$response4$data","deleteConversation","delete","_error$response5","_error$response5$data","uploadFile","file","onProgress","formData","FormData","append","onUploadProgress","progressEvent","total","percentCompleted","Math","round","loaded","_error$response6","_error$response6$data","getHealth","_error$response7","_error$response7$data","getProcessingStatus","processingId","_error$response8","_error$response8$data","systemAPI","checkBackendStatus","available","getStats"],"sources":["/home/im/Druthik/clean_rag/frontend/src/services/api.js"],"sourcesContent":["import axios from 'axios';\n\nconst API_BASE_URL = process.env.REACT_APP_API_URL || '';\n\nconst api = axios.create({\n  baseURL: `${API_BASE_URL}/api`,\n  timeout: 120000,  // 2 minutes for chat\n  headers: {\n    'Content-Type': 'application/json',\n  },\n});\n\n// Request interceptor for logging\napi.interceptors.request.use(\n  (config) => {\n    console.log(`API Request: ${config.method?.toUpperCase()} ${config.url}`);\n    return config;\n  },\n  (error) => {\n    console.error('API Request Error:', error);\n    return Promise.reject(error);\n  }\n);\n\n// Response interceptor for error handling\napi.interceptors.response.use(\n  (response) => {\n    return response;\n  },\n  (error) => {\n    console.error('API Response Error:', error);\n    \n    if (error.response?.status === 500) {\n      console.error('Server Error:', error.response.data);\n    } else if (error.code === 'ECONNABORTED') {\n      console.error('Request timeout');\n    } else if (!error.response) {\n      console.error('Network error - server might be down');\n    }\n    \n    return Promise.reject(error);\n  }\n);\n\nexport const chatAPI = {\n  // Send a message and get response\n  sendMessage: async (message, sessionId = null, stream = false) => {\n    try {\n      if (stream) {\n        // Return a stream for server-sent events\n        const response = await fetch(`${API_BASE_URL}/api/chat`, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n          },\n          body: JSON.stringify({\n            message,\n            session_id: sessionId,\n            stream: true,\n          }),\n        });\n\n        if (!response.ok) {\n          throw new Error(`HTTP error! status: ${response.status}`);\n        }\n\n        return response;\n      } else {\n        const response = await api.post('/chat', {\n          message,\n          session_id: sessionId,\n          stream: false,\n        });\n        return response.data;\n      }\n    } catch (error) {\n      throw new Error(error.response?.data?.error || 'Failed to send message');\n    }\n  },\n\n  // Process streaming response\n  processStream: async function* (response, onChunk = null, onComplete = null, onError = null) {\n    try {\n      const reader = response.body.getReader();\n      const decoder = new TextDecoder();\n      let buffer = '';\n\n      while (true) {\n        const { done, value } = await reader.read();\n        \n        if (done) break;\n\n        buffer += decoder.decode(value, { stream: true });\n        const lines = buffer.split('\\n');\n        buffer = lines.pop(); // Keep the incomplete line in buffer\n\n        for (const line of lines) {\n          if (line.startsWith('data: ')) {\n            try {\n              const data = JSON.parse(line.slice(6));\n              \n              if (data.type === 'chunk' && data.content) {\n                if (onChunk) onChunk(data.content);\n                yield data.content;\n              } else if (data.type === 'complete') {\n                if (onComplete) onComplete(data);\n                return data;\n              } else if (data.type === 'error') {\n                if (onError) onError(data.content);\n                throw new Error(data.content);\n              }\n            } catch (parseError) {\n              console.warn('Failed to parse streaming data:', line);\n            }\n          }\n        }\n      }\n    } catch (error) {\n      if (onError) onError(error.message);\n      throw error;\n    }\n  },\n\n  // Get conversation history\n  getConversationHistory: async (sessionId) => {\n    try {\n      const response = await api.get(`/conversations/${sessionId}`);\n      return response.data;\n    } catch (error) {\n      throw new Error(error.response?.data?.error || 'Failed to get conversation history');\n    }\n  },\n\n  // Get all conversations\n  getAllConversations: async () => {\n    try {\n      const response = await api.get('/conversations');\n      return response.data;\n    } catch (error) {\n      throw new Error(error.response?.data?.error || 'Failed to get conversations');\n    }\n  },\n\n  // Delete a conversation\n  deleteConversation: async (sessionId) => {\n    try {\n      const response = await api.delete(`/conversations/${sessionId}`);\n      return response.data;\n    } catch (error) {\n      throw new Error(error.response?.data?.error || 'Failed to delete conversation');\n    }\n  },\n\n  // Upload a file\n  uploadFile: async (file, onProgress = null) => {\n    try {\n      const formData = new FormData();\n      formData.append('file', file);\n\n      const response = await api.post('/upload', formData, {\n        headers: {\n          'Content-Type': 'multipart/form-data',\n        },\n        onUploadProgress: (progressEvent) => {\n          if (onProgress && progressEvent.total) {\n            const percentCompleted = Math.round(\n              (progressEvent.loaded * 100) / progressEvent.total\n            );\n            onProgress(percentCompleted);\n          }\n        },\n      });\n      \n      return response.data;\n    } catch (error) {\n      throw new Error(error.response?.data?.error || 'Failed to upload file');\n    }\n  },\n\n  // Get system health\n  getHealth: async () => {\n    try {\n      const response = await api.get('/health');\n      return response.data;\n    } catch (error) {\n      throw new Error(error.response?.data?.error || 'Failed to get system health');\n    }\n  },\n\n  // Get processing status\n  getProcessingStatus: async (processingId) => {\n    try {\n      const response = await api.get(`/processing/${processingId}`);\n      return response.data;\n    } catch (error) {\n      throw new Error(error.response?.data?.error || 'Failed to get processing status');\n    }\n  },\n};\n\nexport const systemAPI = {\n  // Check if backend is available\n  checkBackendStatus: async () => {\n    try {\n      const response = await api.get('/health');\n      return { \n        available: true, \n        data: response.data \n      };\n    } catch (error) {\n      return { \n        available: false, \n        error: error.message \n      };\n    }\n  },\n\n  // Get system statistics (if available)\n  getStats: async () => {\n    try {\n      const response = await api.get('/stats');\n      return response.data;\n    } catch (error) {\n      // Stats endpoint might not be available\n      console.warn('Stats endpoint not available:', error.message);\n      return null;\n    }\n  },\n};\n\nexport default api;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}