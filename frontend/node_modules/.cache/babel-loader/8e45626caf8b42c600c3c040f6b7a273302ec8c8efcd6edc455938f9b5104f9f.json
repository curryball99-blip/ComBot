{"ast":null,"code":"function debounce(func, debounceMs) {\n  let {\n    signal,\n    edges\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let pendingThis = undefined;\n  let pendingArgs = null;\n  const leading = edges != null && edges.includes('leading');\n  const trailing = edges == null || edges.includes('trailing');\n  const invoke = () => {\n    if (pendingArgs !== null) {\n      func.apply(pendingThis, pendingArgs);\n      pendingThis = undefined;\n      pendingArgs = null;\n    }\n  };\n  const onTimerEnd = () => {\n    if (trailing) {\n      invoke();\n    }\n    cancel();\n  };\n  let timeoutId = null;\n  const schedule = () => {\n    if (timeoutId != null) {\n      clearTimeout(timeoutId);\n    }\n    timeoutId = setTimeout(() => {\n      timeoutId = null;\n      onTimerEnd();\n    }, debounceMs);\n  };\n  const cancelTimer = () => {\n    if (timeoutId !== null) {\n      clearTimeout(timeoutId);\n      timeoutId = null;\n    }\n  };\n  const cancel = () => {\n    cancelTimer();\n    pendingThis = undefined;\n    pendingArgs = null;\n  };\n  const flush = () => {\n    invoke();\n  };\n  const debounced = function () {\n    if (signal !== null && signal !== void 0 && signal.aborted) {\n      return;\n    }\n    pendingThis = this;\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    pendingArgs = args;\n    const isFirstCall = timeoutId == null;\n    schedule();\n    if (leading && isFirstCall) {\n      invoke();\n    }\n  };\n  debounced.schedule = schedule;\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  signal === null || signal === void 0 || signal.addEventListener('abort', cancel, {\n    once: true\n  });\n  return debounced;\n}\nexport { debounce };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}