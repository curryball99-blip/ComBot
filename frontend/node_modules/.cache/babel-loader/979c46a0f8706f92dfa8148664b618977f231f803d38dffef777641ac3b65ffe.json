{"ast":null,"code":"import { create } from 'zustand';\nimport { persist } from 'zustand/middleware';\nimport { chatAPI } from '../services/api';\nconst useChatStore = create(persist((set, get) => ({\n  // Current conversation state\n  currentSessionId: null,\n  messages: [],\n  isLoading: false,\n  isTyping: false,\n  error: null,\n  // Conversation management\n  conversations: [],\n  isLoadingConversations: false,\n  // UI state\n  sidebarOpen: true,\n  uploadModalOpen: false,\n  // Actions\n  setCurrentSession: async sessionId => {\n    const {\n      currentSessionId\n    } = get();\n\n    // Don't reload if it's the same session\n    if (currentSessionId === sessionId) {\n      return;\n    }\n\n    // Load conversation history if sessionId exists\n    if (sessionId) {\n      set({\n        currentSessionId: sessionId,\n        error: null\n      });\n      await get().loadConversationHistory(sessionId);\n    } else {\n      // Only clear messages for new conversation\n      set({\n        currentSessionId: sessionId,\n        messages: [],\n        error: null\n      });\n    }\n  },\n  // Send a message with streaming support\n  sendMessage: async (messageText, streaming = false) => {\n    const {\n      currentSessionId\n    } = get();\n    set({\n      isLoading: true,\n      error: null\n    });\n\n    // Add user message immediately to UI\n    const userMessage = {\n      id: Date.now().toString(),\n      type: 'user',\n      content: messageText,\n      timestamp: new Date().toISOString()\n    };\n    set(state => ({\n      messages: [...state.messages, userMessage],\n      isTyping: true\n    }));\n    try {\n      if (streaming) {\n        // Streaming response\n        const response = await chatAPI.sendMessage(messageText, currentSessionId, true);\n\n        // Create initial bot message\n        const botMessageId = (Date.now() + 1).toString();\n        const botMessage = {\n          id: botMessageId,\n          type: 'bot',\n          content: '',\n          timestamp: new Date().toISOString(),\n          sources: [],\n          isStreaming: true\n        };\n        set(state => ({\n          messages: [...state.messages, botMessage],\n          isLoading: false,\n          isTyping: false\n        }));\n\n        // Process streaming response\n        let fullContent = '';\n        const streamGenerator = chatAPI.processStream(response, chunk => {\n          fullContent += chunk;\n          // Update the message in real-time\n          set(state => ({\n            messages: state.messages.map(msg => msg.id === botMessageId ? {\n              ...msg,\n              content: fullContent\n            } : msg)\n          }));\n        }, completionData => {\n          // Final update with metadata\n          set(state => ({\n            messages: state.messages.map(msg => msg.id === botMessageId ? {\n              ...msg,\n              content: fullContent,\n              sources: completionData.sources || [],\n              timestamp: completionData.timestamp,\n              isStreaming: false\n            } : msg),\n            currentSessionId: completionData.session_id\n          }));\n\n          // Refresh conversations list\n          get().loadConversations();\n        }, error => {\n          console.error('Streaming error:', error);\n          set(state => ({\n            messages: state.messages.map(msg => msg.id === botMessageId ? {\n              ...msg,\n              type: 'error',\n              content: error,\n              isStreaming: false\n            } : msg),\n            error\n          }));\n        });\n\n        // Consume the generator\n        try {\n          // eslint-disable-next-line no-unused-vars\n          for await (const _ of streamGenerator) {\n            // Chunks are processed in the onChunk callback\n          }\n        } catch (streamError) {\n          console.error('Stream processing error:', streamError);\n        }\n      } else {\n        // Non-streaming response (fallback)\n        const response = await chatAPI.sendMessage(messageText, currentSessionId, false);\n        const botMessage = {\n          id: (Date.now() + 1).toString(),\n          type: 'bot',\n          content: response.response,\n          timestamp: response.timestamp || new Date().toISOString(),\n          sources: response.sources || [],\n          session_id: response.session_id\n        };\n        set(state => ({\n          messages: [...state.messages, botMessage],\n          currentSessionId: response.session_id,\n          isLoading: false,\n          isTyping: false\n        }));\n        get().loadConversations();\n      }\n    } catch (error) {\n      console.error('Failed to send message:', error);\n\n      // Add error message\n      const errorMessage = {\n        id: (Date.now() + 1).toString(),\n        type: 'error',\n        content: error.message || 'Failed to get response. Please try again.',\n        timestamp: new Date().toISOString()\n      };\n      set(state => ({\n        messages: [...state.messages, errorMessage],\n        isLoading: false,\n        isTyping: false,\n        error: error.message\n      }));\n    }\n  },\n  // Load conversation history\n  loadConversationHistory: async sessionId => {\n    if (!sessionId) return;\n    set({\n      isLoading: true,\n      error: null\n    });\n    try {\n      const history = await chatAPI.getConversationHistory(sessionId);\n      console.log('Loaded history for session:', sessionId, history);\n      console.log('First entry structure:', history[0]);\n\n      // Convert history to message format\n      const messages = [];\n      if (history && Array.isArray(history)) {\n        history.forEach(entry => {\n          if (entry.query) {\n            messages.push({\n              id: `${entry.id}-user`,\n              type: 'user',\n              content: entry.query,\n              timestamp: entry.timestamp\n            });\n          }\n          if (entry.response) {\n            messages.push({\n              id: `${entry.id}-bot`,\n              type: 'bot',\n              content: entry.response,\n              timestamp: entry.timestamp,\n              sources: entry.sources || []\n            });\n          }\n        });\n      }\n      console.log('Converted messages:', messages);\n      set({\n        messages,\n        isLoading: false\n      });\n    } catch (error) {\n      console.error('Failed to load conversation history:', error);\n      set({\n        isLoading: false,\n        error: error.message\n      });\n    }\n  },\n  // Load all conversations\n  loadConversations: async () => {\n    set({\n      isLoadingConversations: true\n    });\n    try {\n      const conversations = await chatAPI.getAllConversations();\n      set({\n        conversations: conversations || [],\n        isLoadingConversations: false\n      });\n    } catch (error) {\n      console.error('Failed to load conversations:', error);\n      set({\n        conversations: [],\n        isLoadingConversations: false\n      });\n    }\n  },\n  // Start new conversation\n  startNewConversation: () => {\n    const newSessionId = `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    set({\n      currentSessionId: newSessionId,\n      messages: [],\n      error: null\n    });\n  },\n  // Delete conversation\n  deleteConversation: async sessionId => {\n    try {\n      await chatAPI.deleteConversation(sessionId);\n\n      // Remove from conversations list\n      set(state => ({\n        conversations: state.conversations.filter(conv => conv.session_id !== sessionId)\n      }));\n\n      // If it was the current conversation, start new one\n      const {\n        currentSessionId\n      } = get();\n      if (currentSessionId === sessionId) {\n        get().startNewConversation();\n      }\n    } catch (error) {\n      console.error('Failed to delete conversation:', error);\n      set({\n        error: error.message\n      });\n    }\n  },\n  // Clear messages (for current conversation)\n  clearMessages: () => {\n    set({\n      messages: [],\n      error: null\n    });\n  },\n  // Clear error\n  clearError: () => {\n    set({\n      error: null\n    });\n  },\n  // Toggle sidebar\n  toggleSidebar: () => {\n    set(state => ({\n      sidebarOpen: !state.sidebarOpen\n    }));\n  },\n  // Toggle upload modal\n  toggleUploadModal: () => {\n    set(state => ({\n      uploadModalOpen: !state.uploadModalOpen\n    }));\n  },\n  // Set loading state\n  setLoading: isLoading => {\n    set({\n      isLoading\n    });\n  },\n  // Set typing state\n  setTyping: isTyping => {\n    set({\n      isTyping\n    });\n  }\n}), {\n  name: 'comviva-chat-store',\n  partialize: state => ({\n    currentSessionId: state.currentSessionId,\n    messages: state.messages,\n    sidebarOpen: state.sidebarOpen,\n    conversations: state.conversations\n  })\n}));\nexport default useChatStore;","map":{"version":3,"names":["create","persist","chatAPI","useChatStore","set","get","currentSessionId","messages","isLoading","isTyping","error","conversations","isLoadingConversations","sidebarOpen","uploadModalOpen","setCurrentSession","sessionId","loadConversationHistory","sendMessage","messageText","streaming","userMessage","id","Date","now","toString","type","content","timestamp","toISOString","state","response","botMessageId","botMessage","sources","isStreaming","fullContent","streamGenerator","processStream","chunk","map","msg","completionData","session_id","loadConversations","console","_","streamError","errorMessage","message","history","getConversationHistory","log","Array","isArray","forEach","entry","query","push","getAllConversations","startNewConversation","newSessionId","Math","random","substr","deleteConversation","filter","conv","clearMessages","clearError","toggleSidebar","toggleUploadModal","setLoading","setTyping","name","partialize"],"sources":["/home/im/Druthik/clean_rag/frontend/src/stores/chatStore.js"],"sourcesContent":["import { create } from 'zustand';\nimport { persist } from 'zustand/middleware';\nimport { chatAPI } from '../services/api';\n\nconst useChatStore = create(\n  persist(\n    (set, get) => ({\n      // Current conversation state\n      currentSessionId: null,\n      messages: [],\n      isLoading: false,\n      isTyping: false,\n      error: null,\n\n      // Conversation management\n      conversations: [],\n      isLoadingConversations: false,\n\n      // UI state\n      sidebarOpen: true,\n      uploadModalOpen: false,\n\n      // Actions\n      setCurrentSession: async (sessionId) => {\n        const { currentSessionId } = get();\n        \n        // Don't reload if it's the same session\n        if (currentSessionId === sessionId) {\n          return;\n        }\n        \n        // Load conversation history if sessionId exists\n        if (sessionId) {\n          set({ currentSessionId: sessionId, error: null });\n          await get().loadConversationHistory(sessionId);\n        } else {\n          // Only clear messages for new conversation\n          set({ currentSessionId: sessionId, messages: [], error: null });\n        }\n      },\n\n      // Send a message with streaming support\n      sendMessage: async (messageText, streaming = false) => {\n        const { currentSessionId } = get();\n        \n        set({ isLoading: true, error: null });\n\n        // Add user message immediately to UI\n        const userMessage = {\n          id: Date.now().toString(),\n          type: 'user',\n          content: messageText,\n          timestamp: new Date().toISOString(),\n        };\n\n        set((state) => ({\n          messages: [...state.messages, userMessage],\n          isTyping: true,\n        }));\n\n        try {\n          if (streaming) {\n            // Streaming response\n            const response = await chatAPI.sendMessage(messageText, currentSessionId, true);\n            \n            // Create initial bot message\n            const botMessageId = (Date.now() + 1).toString();\n            const botMessage = {\n              id: botMessageId,\n              type: 'bot',\n              content: '',\n              timestamp: new Date().toISOString(),\n              sources: [],\n              isStreaming: true,\n            };\n\n            set((state) => ({\n              messages: [...state.messages, botMessage],\n              isLoading: false,\n              isTyping: false,\n            }));\n\n            // Process streaming response\n            let fullContent = '';\n            const streamGenerator = chatAPI.processStream(\n              response,\n              (chunk) => {\n                fullContent += chunk;\n                // Update the message in real-time\n                set((state) => ({\n                  messages: state.messages.map((msg) =>\n                    msg.id === botMessageId\n                      ? { ...msg, content: fullContent }\n                      : msg\n                  ),\n                }));\n              },\n              (completionData) => {\n                // Final update with metadata\n                set((state) => ({\n                  messages: state.messages.map((msg) =>\n                    msg.id === botMessageId\n                      ? {\n                          ...msg,\n                          content: fullContent,\n                          sources: completionData.sources || [],\n                          timestamp: completionData.timestamp,\n                          isStreaming: false,\n                        }\n                      : msg\n                  ),\n                  currentSessionId: completionData.session_id,\n                }));\n\n                // Refresh conversations list\n                get().loadConversations();\n              },\n              (error) => {\n                console.error('Streaming error:', error);\n                set((state) => ({\n                  messages: state.messages.map((msg) =>\n                    msg.id === botMessageId\n                      ? { ...msg, type: 'error', content: error, isStreaming: false }\n                      : msg\n                  ),\n                  error,\n                }));\n              }\n            );\n\n            // Consume the generator\n            try {\n              // eslint-disable-next-line no-unused-vars\n              for await (const _ of streamGenerator) {\n                // Chunks are processed in the onChunk callback\n              }\n            } catch (streamError) {\n              console.error('Stream processing error:', streamError);\n            }\n\n          } else {\n            // Non-streaming response (fallback)\n            const response = await chatAPI.sendMessage(messageText, currentSessionId, false);\n            \n            const botMessage = {\n              id: (Date.now() + 1).toString(),\n              type: 'bot',\n              content: response.response,\n              timestamp: response.timestamp || new Date().toISOString(),\n              sources: response.sources || [],\n              session_id: response.session_id,\n            };\n\n            set((state) => ({\n              messages: [...state.messages, botMessage],\n              currentSessionId: response.session_id,\n              isLoading: false,\n              isTyping: false,\n            }));\n\n            get().loadConversations();\n          }\n\n        } catch (error) {\n          console.error('Failed to send message:', error);\n          \n          // Add error message\n          const errorMessage = {\n            id: (Date.now() + 1).toString(),\n            type: 'error',\n            content: error.message || 'Failed to get response. Please try again.',\n            timestamp: new Date().toISOString(),\n          };\n\n          set((state) => ({\n            messages: [...state.messages, errorMessage],\n            isLoading: false,\n            isTyping: false,\n            error: error.message,\n          }));\n        }\n      },\n\n      // Load conversation history\n      loadConversationHistory: async (sessionId) => {\n        if (!sessionId) return;\n\n        set({ isLoading: true, error: null });\n\n        try {\n          const history = await chatAPI.getConversationHistory(sessionId);\n          console.log('Loaded history for session:', sessionId, history);\n          console.log('First entry structure:', history[0]);\n          \n          // Convert history to message format\n          const messages = [];\n          if (history && Array.isArray(history)) {\n            history.forEach((entry) => {\n              if (entry.query) {\n                messages.push({\n                  id: `${entry.id}-user`,\n                  type: 'user',\n                  content: entry.query,\n                  timestamp: entry.timestamp,\n                });\n              }\n              if (entry.response) {\n                messages.push({\n                  id: `${entry.id}-bot`,\n                  type: 'bot',\n                  content: entry.response,\n                  timestamp: entry.timestamp,\n                  sources: entry.sources || [],\n                });\n              }\n            });\n          }\n          console.log('Converted messages:', messages);\n\n          set({\n            messages,\n            isLoading: false,\n          });\n\n        } catch (error) {\n          console.error('Failed to load conversation history:', error);\n          set({\n            isLoading: false,\n            error: error.message,\n          });\n        }\n      },\n\n      // Load all conversations\n      loadConversations: async () => {\n        set({ isLoadingConversations: true });\n\n        try {\n          const conversations = await chatAPI.getAllConversations();\n          set({\n            conversations: conversations || [],\n            isLoadingConversations: false,\n          });\n        } catch (error) {\n          console.error('Failed to load conversations:', error);\n          set({\n            conversations: [],\n            isLoadingConversations: false,\n          });\n        }\n      },\n\n      // Start new conversation\n      startNewConversation: () => {\n        const newSessionId = `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n        set({\n          currentSessionId: newSessionId,\n          messages: [],\n          error: null,\n        });\n      },\n\n      // Delete conversation\n      deleteConversation: async (sessionId) => {\n        try {\n          await chatAPI.deleteConversation(sessionId);\n          \n          // Remove from conversations list\n          set((state) => ({\n            conversations: state.conversations.filter(\n              (conv) => conv.session_id !== sessionId\n            ),\n          }));\n\n          // If it was the current conversation, start new one\n          const { currentSessionId } = get();\n          if (currentSessionId === sessionId) {\n            get().startNewConversation();\n          }\n\n        } catch (error) {\n          console.error('Failed to delete conversation:', error);\n          set({ error: error.message });\n        }\n      },\n\n      // Clear messages (for current conversation)\n      clearMessages: () => {\n        set({ messages: [], error: null });\n      },\n\n      // Clear error\n      clearError: () => {\n        set({ error: null });\n      },\n\n      // Toggle sidebar\n      toggleSidebar: () => {\n        set((state) => ({ sidebarOpen: !state.sidebarOpen }));\n      },\n\n      // Toggle upload modal\n      toggleUploadModal: () => {\n        set((state) => ({ uploadModalOpen: !state.uploadModalOpen }));\n      },\n\n      // Set loading state\n      setLoading: (isLoading) => {\n        set({ isLoading });\n      },\n\n      // Set typing state\n      setTyping: (isTyping) => {\n        set({ isTyping });\n      },\n    }),\n    {\n      name: 'comviva-chat-store',\n      partialize: (state) => ({\n        currentSessionId: state.currentSessionId,\n        messages: state.messages,\n        sidebarOpen: state.sidebarOpen,\n        conversations: state.conversations,\n      }),\n    }\n  )\n);\n\nexport default useChatStore;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}